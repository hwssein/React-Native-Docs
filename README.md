# کتاب آموزشی: از صفر تا قهرمانی با React Native و Expo

---

## مقدمه

به دنیای هیجان‌انگیز توسعه اپلیکیشن موبایل با React Native و Expo خوش آمدید!
- در این کتاب، شما از **مفاهیم پایه تا تکنیک‌های پیشرفته** را فرا خواهید گرفت تا بتوانید ایده‌های خود را به اپلیکیشن‌های موبایل قدرتمند و زیبا برای هر دو پلتفرم iOS و Android تبدیل کنید.
- هدف ما این است که شما را از یک توسعه‌دهنده تازه‌کار به یک متخصص در زمینه React Native و Expo تبدیل کنیم، به گونه‌ای که بتوانید هر ایده‌ای را به یک اپلیکیشن واقعی، باکیفیت و قابل انتشار تبدیل کنید.

- ما مسیر **Expo** را به عنوان استاندارد مدرن و کارآمد دنبال خواهیم کرد.
- این مسیر، شروع کار را به شدت ساده کرده و به شما امکان می‌دهد با تمرکز بر کد جاوااسکریپت، اپلیکیشن‌های نیتیو بسازید، بدون اینکه نیازی به نصب پیچیده Xcode یا Android Studio در ابتدای کار داشته باشید.
- هدف این کتاب، ارائه یک **مسیر یادگیری گام به گام و منطقی** است، به‌گونه‌ای که حتی اگر تجربه قبلی در توسعه موبایل نداشته باشید، بتوانید با اطمینان کامل پیش بروید و در نهایت یک توسعه‌دهنده React Native ماهر شوید.
- آینده توسعه موبایل در دستان شماست. بیایید شروع کنیم! 🚀

---

## فصل ۱: خوش آمدگویی به دنیای React Native

- در این فصل، شما با هسته فلسفه React Native، نحوه کارکرد آن در پشت صحنه، و مهم‌ترین تصمیم اولیه برای شروع پروژه‌هایتان آشنا خواهید شد.
- همچنین، با فلسفه اصلی و معماری منحصر به فرد React Native آشنا می‌شویم و تفاوت‌های کلیدی آن را با سایر رویکردهای توسعه موبایل بررسی می‌کنیم.

### ۱-۱: فلسفه اصلی React Native

- **React Native** یک فریم‌ورک **متن-باز** است.
- این فریم‌ورک به شما اجازه می‌دهد با استفاده از دانش **React** و زبان **جاوااسکریپت**، اپلیکیشن‌های موبایل کاملاً **نیتیو (Native)** برای پلتفرم‌های iOS و Android بسازید.

- **نکته کلیدی و وجه تمایز اصلی React Native** این است که بر خلاف ابزارهایی که یک وب‌سایت را در قاب اپلیکیشن نمایش می‌دهند (**WebView**)، کدهای شما به عناصر واقعی و بومی رابط کاربری در هر پلتفرم ترجمه می‌شوند.
- این معماری باعث می‌شود عملکرد، ظاهر و حس اپلیکیشن شما دقیقاً مانند اپلیکیشنی باشد که با زبان‌های اصلی آن پلتفرم (مانند **Swift** برای iOS یا **Kotlin** برای Android) نوشته شده است.
- به عنوان مثال:
    - `<View>` در کد React Native شما، به `UIView` در iOS و `ViewGroup` در Android تبدیل می‌شود.
    - `<Text>` در کد React Native شما، به `UITextView` در iOS و `TextView` در Android تبدیل خواهد شد.

### ۱-۲: معماری درونی: نخ JS و نخ UI

- یک اپلیکیشن **React Native** در دو "قلمرو" یا **Thread (نخ)** اصلی به صورت موازی عمل می‌کند:

- **نخ جاوااسکریپت (JS Thread):**
    - این نخ مسئولیت اجرای **تمام کدهای React شما**، منطق برنامه، مدیریت وضعیت (state) و فراخوانی APIها را بر عهده دارد.
    - این نخ را می‌توان به عنوان "مغز" یا "فکر کردن" اپلیکیشن در نظر گرفت.

- **نخ اصلی/UI (Main/UI Thread):**
    - این نخ وظیفه **تمام کارهای بصری** را بر عهده دارد؛ از جمله رندر کردن پیکسل‌ها روی صفحه و پاسخ به ژست‌های لمسی کاربر.
    - برای اینکه کاربر تجربه‌ای روان و بدون لگ داشته باشد، این نخ باید همیشه آزاد و سریع باقی بماند.

- این دو نخ از طریق یک مکانیزم ارتباطی مدرن به نام **JSI (JavaScript Interface)** با یکدیگر ارتباط برقرار می‌کنند.
- **JSI** به جاوااسکریپت اجازه می‌دهد تا به صورت **مستقیم** به اشیاء و توابع نیتیو دسترسی پیدا کند، که این امر به بهبود عملکرد و پاسخ‌گویی اپلیکیشن کمک شایانی می‌کند.

### ۱-۳: انتخاب مسیر: Expo در مقابل React Native CLI

- این مهم‌ترین تصمیم در ابتدای هر پروژه **React Native** است.

- **Expo:**
    - یک فریم‌ورک و مجموعه‌ای جامع از ابزارهاست که روی **React Native** ساخته شده تا فرآیند توسعه را به شدت ساده‌تر کند.
    - با **Expo** نیازی به نصب **Xcode** یا **Android Studio** برای شروع کار ندارید.
    - این پلتفرم دسترسی به **مجموعه‌ای عظیم از کتابخانه‌های آماده** را فراهم می‌کند که بسیاری از قابلیت‌های رایج موبایل (مانند دوربین، نقشه، اعلان‌ها) را پوشش می‌دهند.
    - سرویس ابری **EAS** نیز فرآیند ساخت و انتشار اپلیکیشن را به شدت تسهیل می‌کند.
    - **این مسیر برای ۹۹٪ پروژه‌ها پیشنهاد می‌شود**.

- **React Native CLI:**
    - این روش "خالص" و مستقیم استفاده از **React Native** است.
    - به شما **کنترل کامل** روی تمام جنبه‌های نیتیو پروژه را می‌دهد.
    - اما راه‌اندازی و نگهداری آن به طور قابل توجهی پیچیده‌تر است و نیازمند دانش عمیق‌تر از توسعه نیتیو می‌باشد.

- **در این دوره آموزشی، ما مسیر Expo را به عنوان استاندارد مدرن و کارآمد دنبال خواهیم کرد**.

---

## فصل ۲: راه‌اندازی و گردش کار توسعه

- اکنون که با مفاهیم پایه آشنا شدیم، زمان آن رسیده که محیط توسعه خود را راه‌اندازی کرده و اولین اپلیکیشن React Native خود را با Expo بسازیم.
- این فصل شما را با مراحل اولیه، از ساخت پروژه تا اجرای آن روی دستگاه‌های واقعی یا شبیه‌ساز، و همچنین ابزارهای مهم اشکال‌زدایی آشنا می‌کند.

### ۲-۱: راه‌اندازی محیط

- برای ساخت یک پروژه خام (**Blank**) با **Expo** که به طور پیش‌فرض از **TypeScript** استفاده می‌کند، از دستور زیر در ترمینال خود استفاده کنید:

```bash
npx create-expo-app YourProjectName
```

- **توضیح:**
    - **npx:** یک ابزار برای اجرای پکیج‌های Node.js بدون نیاز به نصب سراسری آن‌ها.
    - **create-expo-app:** دستوری که توسط Expo برای ایجاد پروژه‌های جدید ارائه شده است.
    - **YourProjectName:** نامی که می‌خواهید برای پروژه خود انتخاب کنید.
- پس از اینکه پروژه با موفقیت ساخته شد، وارد پوشه پروژه شوید و سرور توسعه (**Metro Bundler**) را با دستور زیر اجرا کنید:

```bash
cd YourProjectName
npm start
```

- **سرور Metro** مسئول کامپایل کردن کد جاوااسکریپت شما و سرویس‌دهی آن به اپلیکیشن در حال اجراست. با اجرای `npm start`، یک **QR Code** در ترمینال نمایش داده می‌شود که برای اجرای اپلیکیشن روی دستگاه واقعی استفاده می‌شود.

### ۲-۲: اجرای اپلیکیشن

- شما دو راه اصلی برای دیدن نتیجه کدهای خود دارید:

1.  **دستگاه واقعی (پیشنهادی):**
    - ابتدا اپلیکیشن **Expo Go** را از App Store (برای iOS) یا Google Play Store (برای Android) روی گوشی هوشمند خود نصب کنید.
    - **اطمینان حاصل کنید که کامپیوتر و گوشی شما به یک شبکه Wi-Fi مشترک متصل هستند**.
    - سپس، **QR Code** نمایش داده شده در ترمینال (پس از اجرای `npm start`) را با استفاده از اپلیکیشن Expo Go در گوشی خود اسکن کنید. اپلیکیشن شما به سرعت روی دستگاه لود و اجرا خواهد شد.

2.  **شبیه‌ساز (Simulator/Emulator):**
    - برای اجرای اپلیکیشن روی شبیه‌ساز iOS، باید **Xcode** را روی یک کامپیوتر Mac نصب کنید.
    - برای اجرای اپلیکیشن روی شبیه‌ساز Android، باید **Android Studio** را روی کامپیوتر خود نصب کنید.
    - پس از نصب و پیکربندی مناسب، می‌توانید یک گوشی را روی کامپیوتر خود شبیه‌سازی کرده و اپلیکیشن را روی آن اجرا کنید.

### ۲-۳: ابزارهای اشکال‌زدایی (Debugging)

- **React Native** و **Expo** ابزارهای قدرتمندی برای اشکال‌زدایی (**Debugging**) ارائه می‌دهند که فرآیند توسعه را سریع‌تر و کارآمدتر می‌کنند:

- **منوی توسعه‌دهنده (Developer Menu):**
    - این منو حاوی گزینه‌های مفیدی برای اشکال‌زدایی و تنظیمات توسعه است.
    - برای باز کردن آن روی دستگاه واقعی، دستگاه را تکان دهید.
    - یا با کلیدهای میانبر در شبیه‌ساز (`Ctrl+Cmd+Z` در iOS یا `Ctrl+M` در ویندوز/لینوکس).

- **Fast Refresh:**
    - یکی از بهترین ویژگی‌های **React Native** که بهره‌وری را به شدت افزایش می‌دهد.
    - با ذخیره کردن کد، تغییرات به صورت **آنی** و **بدون از دست رفتن وضعیت (state) فعلی اپلیکیشن**، روی صفحه اعمال می‌شوند.
    - این بدان معناست که لازم نیست هر بار اپلیکیشن را مجدداً بارگذاری کنید و تجربه توسعه را بسیار سریع‌تر می‌کند.

- **LogBox:**
    - این ابزار به شما کمک می‌کند تا خطاها و هشدارها را به راحتی شناسایی کنید.
    - خطاهای جدی را در یک **صفحه قرمز (RedBox)** تمام صفحه نمایش می‌دهد.
    - هشدارها را در یک **کادر زرد (YellowBox)** در پایین صفحه نمایش می‌دهد.
    - این به شما کمک می‌کند مشکلات را به سرعت شناسایی کنید.

- **Element Inspector:**
    - این ابزار به شما اجازه می‌دهد روی هر عنصر **UI** کلیک کرده و اطلاعات مربوط به استایل، چیدمان (layout) و پراپ‌های آن را بررسی کنید.
    - این ویژگی مشابه ابزار Inspect Element در مرورگرهای وب است و برای درک نحوه رندر شدن کامپوننت‌ها بسیار مفید است.

---

## فصل ۳: آجرهای ساختمان: کامپوننت‌های اصلی (بخش اول)

- در این فصل، با اساسی‌ترین کامپوننت‌های **React Native** که برای ساخت رابط کاربری (**UI**) هر اپلیکیشنی مورد نیاز هستند، آشنا می‌شویم.
- این کامپوننت‌ها به عنوان آجرهای ساختمانی **UI** شما عمل می‌کنند.

### ۳-۱: `<View>` - ظرف اصلی چیدمان

- کامپوننت `<View>` بنیادی‌ترین و پرکاربردترین کامپوننت برای ساخت **UI** در **React Native** است.
- **معادل وب:** در توسعه وب، `<View>` معادل یک `<div>` است.
- **کاربرد:**
    - `<View>` به عنوان یک **کانتینر** برای گروه‌بندی و چیدمان کامپوننت‌های دیگر استفاده می‌شود.
    - به خودی خود دیده نمی‌شود، مگر اینکه به آن استایل (مانند پس‌زمینه یا حاشیه) بدهید.
    - این کامپوننت، بستر اصلی پیاده‌سازی **Flexbox** است که یک سیستم قدرتمند برای چیدمان عناصر در رابط کاربری است.

*توجه: مثال کد برای این بخش در منابع ارائه نشده است.*

### ۳-۲: `<Text>` - تنها راه نمایش متن

- یک قانون بسیار مهم در **React Native** این است که **تمام متن‌ها باید داخل یک کامپوننت `<Text>` قرار بگیرند**.
- شما نمی‌توانید متن را مستقیماً داخل یک `<View>` یا هر کامپوننت دیگری بنویسید.
- **معادل وب:** در وب، `<Text>` می‌تواند معادل تگ‌هایی مانند `<p>`, `<span>`, `<h1>` و غیره باشد.
- **ویژگی:** کامپوننت‌های `<Text>` می‌توانند **داخل هم قرار بگیرند (Nest شوند)** و استایل‌ها را از والد خود به ارث ببرند. این ویژگی برای اعمال استایل‌های متفاوت به بخش‌های مختلف یک جمله مفید است.

*توجه: مثال کد برای این بخش در منابع ارائه نشده است.*

### ۳-۳: `<Image>` - نمایش تصاویر

- کامپوننت `<Image>` برای نمایش انواع تصاویر در اپلیکیشن شما استفاده می‌شود.
- **پراپ اصلی: `source`**. این پراپ مسیر یا **URL** تصویر را مشخص می‌کند.
- **تصاویر محلی:**
    - برای تصاویری که در پوشه پروژه شما قرار دارند (مثلاً در `assets/images`)، باید از تابع `require` استفاده کنید.
    - این کار به باندلر (**Metro**) کمک می‌کند تا عکس را در بسته نهایی اپلیکیشن قرار دهد و در زمان کامپایل، آن را مدیریت کند.
    - **مثال:**
    ```javascript
    <Image source={require('./assets/image.png')} />
    ```

- **تصاویر اینترنتی:**
    - برای عکس‌هایی که از یک **URL** بارگذاری می‌شوند، باید از یک آبجکت با کلید `uri` در پراپ `source` استفاده کنید.
    - **حتماً** `width` و `height` را در استایل مشخص کنید، در غیر این صورت تصویر نمایش داده نخواهد شد.
    - **مثال:**
    ```javascript
    <Image
      source={{ uri: 'https://reactnative.dev/img/tiny_logo.png' }}
      style={{ width: 50, height: 50 }}
    />
    ```

### ۳-۴: `<TextInput>` - دریافت ورودی از کاربر

- کامپوننت `<TextInput>` برای ساختن فیلدهای ورودی متن استفاده می‌شود و به کاربر امکان می‌دهد تا متن را وارد کند.
- **معادل وب:** این کامپوننت معادل تگ `<input type="text">` در وب است.
- **مهم‌ترین پراپ‌ها:**
    - `value`: برای **کنترل مقدار ورودی** از طریق **state** در **React** استفاده می‌شود. این باعث می‌شود `TextInput` یک "کامپوننت کنترل‌شده" باشد.
    - `onChangeText`: تابعی که با **هر تغییر** در متن ورودی توسط کاربر فراخوانی می‌شود. این تابع معمولاً برای به‌روزرسانی **state** مربوط به مقدار ورودی استفاده می‌شود.
    - `placeholder`: برای نمایش **متن جایگزین** (**Hint text**) در فیلد ورودی زمانی که خالی است، استفاده می‌شود.
    - `keyboardType`: برای تعیین **نوع کیبورد** مجازی که برای کاربر نمایش داده می‌شود. برای مثال، `numeric` برای ورودی‌های عددی یا `email-address` برای آدرس ایمیل.
    - `secureTextEntry`: یک مقدار `boolean` است که اگر `true` باشد، متن وارد شده را مخفی می‌کند (مانند فیلدهای رمز عبور).

*توجه: مثال کد برای این بخش در منابع ارائه نشده است.*

---

## فصل ۴: آجرهای ساختمان: کامپوننت‌های اصلی (بخش دوم)

- در این فصل، با دیگر کامپوننت‌های اصلی **React Native** که برای ساخت یک اپلیکیشن کامل و تعاملی نیاز دارید، آشنا می‌شویم.
- این کامپوننت‌ها امکاناتی از جمله تعاملات لمسی، نمایش محتوای موقت، و کنترل وضعیت‌های مختلف را فراهم می‌کنند.

### ۴-۱: `<Pressable>` - تعامل‌پذیری کامل

- کامپوننت `<Pressable>` مدرن‌ترین و اصلی‌ترین راه برای مدیریت هر نوع تعامل لمسی در **React Native** است.
- `<Pressable>` به عنوان یک "لفافه" (**Wrapper**) عمل می‌کند؛ هر چیزی را که داخل آن قرار دهید، قابل کلیک و تعامل لمسی می‌شود.

- **پراپ‌های اصلی:**
    - `onPress`: تابعی که هنگام یک **کلیک کوتاه** یا ضربه زدن فراخوانی می‌شود.
    - `onLongPress`: تابعی که هنگام **فشردن طولانی** یک عنصر فراخوانی می‌شود.
- **قابلیت کلیدی:** یکی از ویژگی‌های قدرتمند `<Pressable>` این است که می‌توانید به پراپ `style` آن یک **تابع** بدهید. این تابع یک آبجکت شامل وضعیت `pressed` را دریافت می‌کند (`(style={({ pressed }) => ...})`) و به شما اجازه می‌دهد تا بر اساس وضعیت فشرده شدن، استایل کامپوننت را به صورت **داینامیک تغییر دهید**. این ویژگی برای ایجاد دکمه‌هایی با بازخورد بصری زیبایی هنگام لمس بسیار مفید است.

*توجه: مثال کد برای این بخش در منابع ارائه نشده است.*

### ۴-۲: `<Button>` - دکمه ساده نیتیو

- کامپوننت `<Button>` یک دکمه استاندارد سیستم‌عامل را نمایش می‌دهد.
- **تفاوت اصلی با `<Pressable>`:**
    - ظاهر `<Button>` کاملاً **بومی** است.
    - **قابلیت استایل‌دهی بسیار محدودی** دارد.
    - ظاهر آن در iOS و Android متفاوت خواهد بود و شما نمی‌توانید استایل‌های پیچیده‌ای روی آن اعمال کنید.
- **پراپ‌های اصلی:** `title` (برای متن دکمه)، `onPress` (برای تابع کلیک)، و `color` (برای تغییر رنگ دکمه، در اندروید رنگ پس‌زمینه و در iOS رنگ متن).
- **چه زمانی استفاده کنیم؟** `<Button>` برای کارهای سریع و موقتی مانند دکمه‌های داخل یک `Alert` یا برای نمونه‌سازی اولیه سریع مناسب است. برای ساخت دکمه‌های اصلی اپلیکیشن که نیاز به ظاهر سفارشی و یکپارچه در سراسر اپلیکیشن دارند، تقریباً همیشه از **`<Pressable>`** استفاده می‌شود.

*توجه: مثال کد برای این بخش در منابع ارائه نشده است.*

### ۴-۳: `<Modal>` - نمایش محتوا روی صفحه

- کامپوننت `<Modal>` برای نمایش محتوا به صورت موقت و **روی نمای اصلی اپلیکیشن** استفاده می‌شود. این کامپوننت معمولاً برای نمایش دیالوگ‌های پاپ‌آپ، فرم‌های موقت یا پیام‌های تأیید کاربرد دارد.
- **پراپ‌های اصلی:**
    - `visible`: یک مقدار **boolean** که نمایش یا عدم نمایش **Modal** را کنترل می‌کند. اگر `true` باشد، مودال نمایش داده می‌شود.
    - `animationType`: نوع انیمیشن ورود مودال را مشخص می‌کند. مقادیر ممکن `'slide'` (از پایین به بالا)، `'fade'` (محو شدن) یا `'none'` (بدون انیمیشن) هستند.
    - `onRequestClose`: این تابع برای **پشتیبانی از دکمه بازگشت در اندروید** ضروری است. با فشردن دکمه بازگشت سخت‌افزاری، این تابع فراخوانی می‌شود و شما می‌توانید با به‌روزرسانی وضعیت `visible`، مودال را ببندید.

*توجه: مثال کد برای این بخش در منابع ارائه نشده است.*

### ۴-۴: `<StatusBar>` - کنترل نوار وضعیت

- کامپوننت `<StatusBar>` به شما اجازه می‌دهد تا **نوار وضعیت بالای صفحه** (جایی که ساعت، وضعیت باتری و آیکون‌های اعلان نمایش داده می‌شود) را کنترل کنید.
- **پراپ‌های اصلی:**
    - `barStyle`: رنگ متن و آیکون‌ها در نوار وضعیت را تعیین می‌کند. مقادیر ممکن عبارتند از:
        - `'default'`
        - `'light-content'` (مناسب برای پس‌زمینه‌های تیره نوار وضعیت)
        - `'dark-content'` (مناسب برای پس‌زمینه‌های روشن نوار وضعیت)
    - `backgroundColor`: رنگ پس‌زمینه نوار وضعیت را تعیین می‌کند. **این پراپ فقط در اندروید کار می‌کند**.
    - `hidden`: یک مقدار `boolean` که برای **مخفی کردن نوار وضعیت** استفاده می‌شود.

*توجه: مثال کد برای این بخش در منابع ارائه نشده است.*

### ۴-۵: `<Switch>` - کلید دو حالته

- کامپوننت `<Switch>` یک کلید روشن/خاموش استاندارد نیتیو را نمایش می‌دهد. این کامپوننت معمولاً برای تنظیمات کاربری یا فعال/غیرفعال کردن قابلیت‌ها استفاده می‌شود.
- **پراپ‌های اصلی:**
    - `value`: یک مقدار `boolean` که **وضعیت فعلی کلید** (روشن یا خاموش) را مشخص می‌کند.
    - `onValueChange`: تابعی که با **تغییر وضعیت کلید توسط کاربر** فراخوانی می‌شود. این تابع مقدار جدید `boolean` کلید را به عنوان آرگومان دریافت می‌کند و شما باید از آن برای به‌روزرسانی **state** مربوطه استفاده کنید.

*توجه: مثال کد برای این بخش در منابع ارائه نشده است.*

### ۴-۶: `Alert` API

- **Alert** یک کامپوننت **React Native** نیست، بلکه یک **API** است.
- این **API** به شما اجازه می‌دهد تا یک دیالوگ هشدار استاندارد سیستم‌عامل را نمایش دهید. این دیالوگ‌ها برای نمایش پیام‌های مهم، درخواست تأیید کاربر یا نمایش خطاها مناسب هستند.

- شما تابع `Alert.alert(title, message, buttons)` را فراخوانی می‌کنید.
    - `title`: عنوان دیالوگ.
    - `message`: پیام اصلی دیالوگ.
    - `buttons`: (اختیاری) آرایه‌ای از آبجکت‌ها برای تعریف دکمه‌ها. هر آبجکت دکمه می‌تواند شامل `text`، `onPress` (تابعی که با کلیک روی دکمه اجرا می‌شود) و `style` (مثلاً `'cancel'` یا `'destructive'`) باشد.
- **مثال:**

```javascript
import { Alert, Button } from 'react-native';

<Button
  title="نمایش هشدار"
  onPress={() =>
    Alert.alert(
      'عنوان هشدار',
      'این یک پیام هشدار است!',
      [
        {
          text: 'لغو',
          onPress: () => console.log('لغو شد'),
          style: 'cancel',
        },
        {
          text: 'تایید',
          onPress: () => console.log('تایید شد'),
        },
      ]
    )
  }
/>
```

---

## فصل ۵: هنر چیدمان و استایل‌دهی

- در این فصل، به قلب طراحی رابط کاربری در **React Native** می‌رویم و تکنیک‌های پیشرفته‌تری را برای ساخت **UI**های زیبا و واکنش‌گرا (**Responsive**) یاد می‌گیریم.
- تسلط بر این مفاهیم برای ساخت اپلیکیشن‌هایی که در اندازه‌ها و جهت‌گیری‌های مختلف صفحه نمایش به خوبی کار می‌کنند، ضروری است.

### ۵-۱: موقعیت‌یابی مطلق (Absolute Positioning)

- به طور پیش‌فرض، تمام کامپوننت‌ها در **React Native** دارای `position: 'relative'` هستند. این بدان معناست که آن‌ها در جریان عادی چیدمان (**Flow Layout**) قرار می‌گیرند و نسبت به موقعیت خودشان جابجا می‌شوند.
- اما گاهی اوقات شما نیاز دارید که یک عنصر را **روی** عناصر دیگر قرار دهید، به گونه‌ای که از جریان عادی چیدمان خارج شود. به عنوان مثال، قرار دادن یک نشان تعداد اعلان (**Badge**) روی یک آیکون. در این مواقع، از `position: 'absolute'` استفاده می‌کنیم.
- عنصری که این استایل را دارد، نسبت به نزدیک‌ترین والد خود که `position` آن `relative` (که پیش‌فرض است) یا `absolute` باشد، موقعیت‌یابی می‌شود.

*توجه: مثال کد برای این بخش در منابع ارائه نشده است.*

### ۵-۲: استایل‌دهی ریسپانسیو

- ساخت **UI** که روی اندازه‌های مختلف صفحه (گوشی‌های کوچک، تبلت‌ها، حالت افقی و عمودی) خوب به نظر برسد، ترکیبی از چند تکنیک مهم است:

1.  **Flexbox:**
    - این ابزار، **بهترین ابزار شما برای چیدمان ریسپانسیو** است.
    - با استفاده از `flex: 1` به کامپوننت‌ها اجازه می‌دهید فضای موجود را پر کنند و به صورت انعطاف‌پذیر گسترش یابند.
    - با پراپ‌های `justifyContent` (توزیع فضا در جهت اصلی) و `alignItems` (توزیع فضا در جهت متقاطع) نیز می‌توانید توزیع فضا و تراز کردن عناصر را به دقت مدیریت کنید.

*توجه: مثال کد برای Flexbox در این بخش از منابع ارائه نشده است.*

2.  **درصد (%):**
    - می‌توانید برای پراپ‌هایی مانند `width` و `height` از مقادیر **درصدی** استفاده کنید.
    - این کار باعث می‌شود اندازه یک عنصر همیشه نسبتی از اندازه والدش باشد و با تغییر اندازه والد، اندازه آن نیز متناسباً تغییر کند.

*توجه: مثال کد برای درصد در این بخش از منابع ارائه نشده است.*

3.  **`useWindowDimensions`:**
    - این **هوک** (**Hook**) ابعاد فعلی صفحه نمایش (عرض و ارتفاع) را به شما می‌دهد.
    - می‌توانید از آن برای تصمیم‌گیری‌های بزرگ در چیدمان استفاده کنید. به عنوان مثال، اگر عرض صفحه از یک مقدار مشخص (مثلاً ۶۰۰ پیکسل برای تبلت) بیشتر بود، یک لیست را به جای تک ستونه، دو ستونه نمایش دهید.
    - **مثال:**
    ```javascript
    import { useWindowDimensions, View, Text } from 'react-native';

    function MyComponent() {
      const { width } = useWindowDimensions();
      return (
        <View style={{ flex: 1, backgroundColor: width > 500 ? 'lightblue' : 'lightgreen' }}>
          <Text>عرض صفحه: {width}</Text>
        </View>
      );
    }
    ```

### ۵-۳: کدنویسی مختص پلتفرم

- گاهی اوقات، لازم است که ظاهر یا رفتار اپلیکیشن شما در iOS و Android متفاوت باشد، زیرا هر پلتفرم دستورالعمل‌های طراحی خاص خود را دارد. **React Native** ابزارهایی برای مدیریت این تفاوت‌ها ارائه می‌دهد:

1.  **ماژول `Platform`:**
    - این ماژول به شما اجازه می‌دهد در لحظه چک کنید که کد شما روی کدام سیستم‌عامل در حال اجراست.
    - `Platform.OS`: یک رشته `'ios'` یا `'android'` را برمی‌گرداند.
    - `Platform.select()`: **تمیزترین و توصیه شده‌ترین راه** برای تعریف استایل‌ها یا مقادیر متفاوت بر اساس پلتفرم است. این تابع یک آبجکت دریافت می‌کند که کلیدهای آن نام پلتفرم‌ها (مثلاً `ios`, `android`) و مقادیر آن‌ها استایل‌ها یا مقادیر مورد نظر هستند.
    - **مثال (`Platform.select()`):**
    ```javascript
    import { StyleSheet, Platform } from 'react-native';

    const styles = StyleSheet.create({
      card: {
        ...Platform.select({
          ios: { shadowColor: '#000', shadowOpacity: 0.1, shadowRadius: 5, shadowOffset: { width: 0, height: 2 } },
          android: { elevation: 3 },
        }),
        backgroundColor: 'white',
        padding: 20,
        margin: 10,
        borderRadius: 8,
      },
    });
    ```
    - همانطور که در مثال بالا مشاهده می‌کنید، می‌توانیم از `Platform.select()` برای ادغام استایل‌های مخصوص پلتفرم در یک شیء استایل استفاده کنیم. همچنین می‌توانیم از `Platform.OS` به صورت شرطی برای تغییر مقادیر خاص استفاده کنیم.

2.  **پسوندهای فایل (File Extensions):**
    - برای تفاوت‌های بزرگتر در کامپوننت‌ها یا منطق، می‌توانید دو فایل جداگانه بسازید. برای مثال:
        - `MyComponent.ios.js` (فقط برای iOS)
        - `MyComponent.android.js` (فقط برای Android)
    - باندلر **React Native (Metro)** به صورت هوشمند و خودکار فایل صحیح را بر اساس پلتفرم در حال اجرا انتخاب و بارگذاری می‌کند.
    - این رویکرد به شما اجازه می‌دهد تا بخش‌های بزرگی از **UI** یا منطق را به طور کامل برای هر پلتفرم بهینه کنید. این روش برای جداسازی کامل کد مختص هر پلتفرم بسیار مفید است.

---

## فصل ۶: نمایش لیست‌های بهینه

- نمایش لیست‌های داده یکی از رایج‌ترین و حیاتی‌ترین کارها در توسعه اپلیکیشن‌های موبایل است.
- در این فصل، با سه کامپوننت اصلی برای نمایش لیست‌ها آشنا می‌شویم و یاد می‌گیریم که چگونه لیست‌های بلند را به صورت بهینه رندر کنیم تا عملکرد اپلیکیشن شما روان باقی بماند.

### ۶-۱: `<ScrollView>`

- کامپوننت `<ScrollView>` یک کانتینر اسکرول ساده است. هر چیزی که داخل آن قرار دهید، اگر از فضای موجود بزرگ‌تر باشد، قابل اسکرول خواهد شد.

- **نقطه ضعف بزرگ:** `ScrollView` تمام کامپوننت‌های فرزند خود را **یکجا رندر می‌کند**.
    - این بدان معناست که حتی اگر آیتمی خارج از صفحه باشد و کاربر آن را نبیند، باز هم در حافظه رندر شده و فضای زیادی را اشغال می‌کند.
    - این ویژگی باعث می‌شود برای لیست‌های **بلند** (با تعداد زیادی آیتم)، مصرف حافظه بالا رفته و اپلیکیشن **کند** شود.
- **کاربرد:** `ScrollView` برای صفحاتی با **تعداد محدودی آیتم** یا محتوای متنی بلند (مانند یک مقاله یا صفحه تنظیمات) که حجم داده زیادی ندارند، مناسب است.

*توجه: مثال کد برای این بخش در منابع ارائه نشده است.*

### ۶-۲: `<FlatList>` (انتخاب استاندارد)

- کامپوننت `<FlatList>` اصلی‌ترین و **بهینه‌ترین** کامپوننت برای نمایش **لیست‌های بلند و پویا** از داده‌ها است.

- **قابلیت کلیدی: مجازی‌سازی (Virtualization).**
    - `FlatList` به صورت هوشمند عمل می‌کند و **فقط آیتم‌هایی را رندر می‌کند که در حال حاضر روی صفحه قابل مشاهده هستند** (یا نزدیک به آن‌ها هستند).
    - هنگامی که کاربر اسکرول می‌کند، آیتم‌های قدیمی از حافظه حذف شده و آیتم‌های جدید رندر می‌شوند.
    - این کار عملکرد را فوق‌العاده بالا می‌برد و مصرف حافظه را بهینه می‌کند.

- **پراپ‌های ضروری:**
    - `data`: **آرایه‌ای از داده‌ها** که قرار است در لیست نمایش داده شوند.
    - `renderItem`: یک **تابع** که یک آیتم از آرایه `data` را به عنوان ورودی (`{ item, index }`) دریافت کرده و **کامپوننت مربوط به آن آیتم** را برمی‌گرداند. این تابع مسئول نمایش هر ردیف در لیست است.
    - `keyExtractor`: یک **تابع** که یک **کلید (key) منحصر به فرد و از نوع رشته** برای هر آیتم در لیست برمی‌گرداند. **React** از این کلیدها برای شناسایی آیتم‌ها در طول تغییرات (اضافه شدن، حذف شدن، تغییر ترتیب) استفاده می‌کند و برای عملکرد و جلوگیری از باگ‌ها بسیار مهم است.

- **مثال:**

```javascript
import React from 'react';
import { FlatList, Text, View, StyleSheet } from 'react-native';

const DATA = [
  { id: '1', title: 'آیتم اول' },
  { id: '2', title: 'آیتم دوم' },
  { id: '3', title: 'آیتم سوم' },
];

const Item = ({ title }) => (
  <View style={styles.item}>
    <Text style={styles.title}>{title}</Text>
  </View>
);

export default function MyFlatList() {
  return (
    <FlatList
      data={DATA}
      renderItem={({ item }) => <Item title={item.title} />}
      keyExtractor={item => item.id}
    />
  );
}

const styles = StyleSheet.create({
  item: {
    backgroundColor: '#f9c2ff',
    padding: 20,
    marginVertical: 8,
    marginHorizontal: 16,
  },
  title: {
    fontSize: 20,
  },
});
```

### ۶-۳: `<SectionList>`

- کامپوننت `<SectionList>` برای نمایش داده‌هایی است که به صورت **بخش‌بندی شده** یا گروه‌بندی شده هستند. مثال بارز آن، لیست مخاطبین است که بر اساس حروف الفبا (`A, B, C` و...) گروه‌بندی شده‌اند.
- **پراپ‌های اصلی:**
    - `sections`: **آرایه‌ای از آبجکت‌ها** است. هر آبجکت در این آرایه نشان‌دهنده یک بخش است و شامل یک `title` (عنوان بخش) و یک آرایه `data` (آیتم‌های آن بخش) می‌باشد.
    - `renderItem`: برای رندر هر آیتم در یک بخش. مشابه `FlatList` عمل می‌کند.
    - `renderSectionHeader`: تابعی برای **رندر کردن هدر هر بخش** (مثلاً حرف `'A'` برای بخش "آ"). این تابع یک آبجکت شامل `section` (که حاوی `title` آن بخش است) را دریافت می‌کند.

*توجه: مثال کد برای این بخش در منابع ارائه نشده است.*

---

## فصل ۷: هویت بصری: فونت و صفحه اسپلش

- در این فصل، دو ابزار مهم برای کنترل هویت بصری و تجربه اولیه کاربری اپلیکیشن خود را یاد می‌گیریم.
- استفاده از فونت‌های سفارشی می‌تواند برند شما را تقویت کند، و مدیریت صفحه اسپلش تجربه کاربری را هنگام بارگذاری اولیه بهبود می‌بخشد.

### ۷-۱: کار با فونت‌های سفارشی (`useFonts`)

- برای استفاده از فونت‌های اختصاصی (**Custom Fonts**) در پروژه **React Native** و **Expo**، از هوک `useFonts` که از کتابخانه `expo-font` می‌آید، استفاده می‌کنیم.
- این هوک به ما اجازه می‌دهد فونت‌ها را قبل از استفاده، به صورت **غیرهمزمان (asynchronously)** بارگذاری کنیم تا از پدیده "پرش متن" (**Flash Of Unstyled Text - FOUT**) جلوگیری شود.

- **فرآیند استفاده:**
    1.  **نصب کتابخانه:** ابتدا کتابخانه `expo-font` را نصب کنید:
        - `npx expo install expo-font`
    2.  **قرار دادن فایل‌های فونت:** فایل‌های فونت خود (`.ttf` یا `.otf`) را در یک پوشه مناسب داخل پروژه خود، معمولاً `assets/fonts/`، قرار دهید.
    3.  **بارگذاری فونت‌ها با `useFonts`:** در کامپوننت اصلی اپلیکیشن خود (معمولاً `App.js` یا `app/_layout.tsx` در پروژه‌های **Expo Router**)، هوک `useFonts` را فراخوانی کنید. این هوک یک آبجکت دریافت می‌کند که نام‌هایی که می‌خواهید برای فونت‌ها استفاده کنید را به مسیر فایل آن‌ها نگاشت می‌کند. این هوک یک آرایه دو عنصری برمی‌گرداند: یک مقدار بولی (`fontsLoaded`) که نشان می‌دهد آیا فونت‌ها بارگذاری شده‌اند یا خیر، و یک تابع `fontError`.
    4.  **توقف رندر تا بارگذاری کامل:** تا زمانی که فونت‌ها به طور کامل بارگذاری نشده‌اند (`fontsLoaded` برابر `false` است)، رندر اپلیکیشن را متوقف کنید. معمولاً با برگرداندن `null` یا یک صفحه بارگذاری ساده این کار انجام می‌شود.
    5.  **استفاده از فونت:** پس از بارگذاری موفق، می‌توانید نام تعریف شده برای فونت را در پراپ `fontFamily` در استایل‌های خود استفاده کنید.

- **نکته مهم:** بارگذاری فونت به تنهایی آن را به کل برنامه اعمال **نمی‌کند**. شما باید به صراحت در استایل‌ها (مثلاً برای `<Text>`) از آن استفاده کنید.
- **مثال (در `app/_layout.tsx` یا `App.js`):**

```javascript
import { useFonts } from 'expo-font';
import * as SplashScreen from 'expo-splash-screen';
import { useEffect } from 'react';
import { Text, View } from 'react-native';

// جلوگیری از مخفی شدن خودکار صفحه اسپلش تا زمانی که فونت‌ها بارگذاری شوند
SplashScreen.preventAutoHideAsync();

export default function RootLayout() {
  const [fontsLoaded] = useFonts({
    'OpenSans-Regular': require('./assets/fonts/OpenSans-Regular.ttf'),
    'OpenSans-Bold': require('./assets/fonts/OpenSans-Bold.ttf'),
  });

  useEffect(() => {
    if (fontsLoaded) {
      SplashScreen.hideAsync(); // مخفی کردن صفحه اسپلش پس از بارگذاری فونت‌ها
    }
  }, [fontsLoaded]);

  if (!fontsLoaded) {
    return null; // نمایش ندادن هیچ چیزی تا فونت‌ها بارگذاری شوند
  }

  return (
    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
      <Text style={{ fontFamily: 'OpenSans-Bold', fontSize: 24 }}>
        متن با فونت سفارشی
      </Text>
      <Text style={{ fontFamily: 'OpenSans-Regular', fontSize: 18, marginTop: 10 }}>
        این یک متن عادی با فونت سفارشی است.
      </Text>
    </View>
  );
}
```

### ۷-۲: مدیریت صفحه اسپلش (`expo-splash-screen`)

- صفحه اسپلش (**Splash Screen**) اولین چیزی است که کاربر هنگام باز کردن اپلیکیشن شما می‌بیند.
- با استفاده از ماژول `expo-splash-screen`، می‌توانیم نمایش این صفحه را کنترل کنیم تا اطمینان حاصل شود که تمام فرآیندهای آماده‌سازی اولیه اپلیکیشن (مانند بارگذاری فونت‌ها یا دریافت تنظیمات اولیه از سرور) به پایان رسیده‌اند و سپس اپلیکیشن به نرمی نمایش داده شود.

- **گردش کار:**
    1.  **نصب ماژول:**
        - `npx expo install expo-splash-screen`
    2.  **جلوگیری از بسته شدن خودکار:** در ابتدای برنامه، معمولاً در فایل اصلی (مثلاً `App.js` یا `_layout.tsx`) با فراخوانی `SplashScreen.preventAutoHideAsync()` از بسته شدن خودکار صفحه اسپلش قبل از آماده شدن کامل اپلیکیشن جلوگیری می‌کنیم.
    3.  **پنهان کردن صفحه اسپلش:** پس از اینکه تمام کارهای لازم (مانند بارگذاری فونت‌ها، دریافت داده‌های اولیه) انجام شد و اپلیکیشن آماده نمایش است، تابع `SplashScreen.hideAsync()` را فراخوانی می‌کنیم. این باعث می‌شود صفحه اسپلش به نرمی محو شده و محتوای اصلی اپلیکیشن نمایش داده شود. این کار معمولاً در یک `useEffect` یا با استفاده از `onLayout` کامپوننت ریشه انجام می‌شود.

- **مثال (کامل شده با مثال فونت در بالا):**
    - لطفاً به مثال کد ارائه شده در بخش **۷-۱: کار با فونت‌های سفارشی (`useFonts`)** مراجعه کنید، چرا که شامل پیاده‌سازی همزمان `SplashScreen.preventAutoHideAsync()` و `SplashScreen.hideAsync()` است.

---

## فصل ۸: ناوبری مدرن با Expo Router و هوک‌های کاربردی

- ناوبری (**Navigation**) ستون فقرات هر اپلیکیشن موبایل است که به کاربر امکان می‌دهد بین صفحات مختلف جابجا شود.
- در این فصل، با **Expo Router** آشنا می‌شویم، یک رویکرد نوین برای مدیریت ناوبری در **React Native** که بر پایه **مسیریابی مبتنی بر فایل** عمل می‌کند و تجربه توسعه را به شدت ساده‌تر می‌سازد.
- **Expo Router** یک لایه هوشمند روی کتابخانه قدرتمند **React Navigation** است. این به ما اجازه می‌دهد ناوبری را به صورت فایل‌محور و شبیه به **Next.js** انجام دهیم. این رویکرد کدنویسی ناوبری را بسیار تمیزتر و قابل پیش‌بینی‌تر می‌کند.

### ۸-۱: مفاهیم کلیدی Expo Router

- **مسیریابی مبتنی بر فایل:**
    - اساسی‌ترین مفهوم در **Expo Router** این است که **هر فایل در پوشه `app/` به صورت خودکار به یک مسیر (Route) در اپلیکیشن تبدیل می‌شود**.
    - برای مثال، فایل `app/settings.tsx` به مسیر `/settings` در اپلیکیشن شما تبدیل می‌شود.
    - `app/index.tsx` به مسیر اصلی `/` تبدیل می‌شود.
    - پوشه‌ها نیز مسیرهای تو در تو (**Nested Routes**) ایجاد می‌کنند: `app/users/profile.tsx` به `/users/profile` تبدیل می‌شود.

- **چیدمان‌ها (`_layout.tsx`):**
    - این فایل یک مفهوم بسیار قدرتمند است. فایل `_layout.tsx` در یک پوشه، **نوع ناوبر (Navigator)** را برای آن پوشه و **تمام زیرشاخه‌هایش** مشخص می‌کند.
    - `app/_layout.tsx`: این فایل، **ناوبر اصلی کل برنامه** را تعریف می‌کند. معمولاً اینجا یک `Stack` Navigator (ناوبر پشته‌ای) یا `Tab` Navigator (ناوبر تب‌دار) تعریف می‌شود.
    - شما می‌توانید چندین فایل `_layout.tsx` در زیرپوشه‌ها داشته باشید تا بخش‌های مختلف اپلیکیشن، ناوبری خاص خود را داشته باشند.

- **گروه‌بندی مسیرها (Route Groups):**
    - پوشه‌هایی که نامشان داخل **پرانتز** است (مانند `(tabs)`)، در **URL** نهایی تأثیری ندارند.
    - این پوشه‌ها فقط برای **سازماندهی کد** و **اعمال یک چیدمان (layout) خاص** به گروهی از صفحات استفاده می‌شوند.
    - مثال: اگر `app/(tabs)/home.tsx` داشته باشید، مسیر آن همچنان `/home` خواهد بود، اما می‌توانید یک `app/(tabs)/_layout.tsx` برای تعریف یک `Tab Navigator` برای تمام صفحات داخل `(tabs)` داشته باشید.

### ۸-۲: ابزارهای ناوبری: کامپوننت `Link`

- کامپوننت **`Link`** اصلی‌ترین ابزار شما برای **ناوبری اعلانی (Declarative Navigation)** در **React Native** است. این کامپوننت به شما اجازه می‌دهد تا با کلیک کاربر، او را به یک صفحه دیگر منتقل کنید.
- `href`: این پراپ مسیر مقصد را مشخص می‌کند. می‌توانید یک رشته ساده (مانند `href="/settings"`) یا یک آبجکت پیچیده‌تر برای ارسال پارامترها (مانند `href={{ pathname: '/user/123', params: { ... } }}`) به آن بدهید.
- `replace`: این پراپ یک مقدار `boolean` می‌پذیرد. اگر `true` باشد، صفحه فعلی را از **تاریخچه ناوبری (Navigation Stack)** حذف می‌کند و صفحه جدید را جایگزین آن می‌کند. کاربر دیگر نمی‌تواند با دکمه بازگشت به صفحه قبلی بازگردد. این برای سناریوهایی مانند **بعد از ورود کاربر (Login)** که نمی‌خواهید کاربر بتواند به صفحه ورود برگردد، بسیار مفید است.
- `asChild`: این پراپ (که **بسیار مهم** است) به **`Link`** می‌گوید که خودش هیچ **UI** ای را رندر نکند و **فقط قابلیت ناوبری را به اولین فرزند خود منتقل کند**. این به شما اجازه می‌دهد تا دکمه‌های کاملاً سفارشی، آیکون‌ها یا هر کامپوننت دیگری را بسازید که مانند یک لینک عمل می‌کنند.

- **مثال‌ها:**

```javascript
import { Link } from 'expo-router';
import { Button, Pressable, Text, View } from 'react-native';

// ...

// استفاده از Link ساده
<Link href="/settings">رفتن به تنظیمات</Link>

// استفاده از replace
<Link href="/dashboard" replace>ورود به داشبورد</Link>

// استفاده از asChild برای یک دکمه سفارشی
<Link href="/profile" asChild>
  <Pressable style={{ padding: 10, backgroundColor: 'blue', borderRadius: 5 }}>
    <Text style={{ color: 'white' }}>مشاهده پروفایل</Text>
  </Pressable>
</Link>

// ارسال پارامترها با href (آبجکت)
<Link href={{ pathname: "/user/[id]", params: { id: '123' } }}>
  مشاهده کاربر 123
</Link>
```

### ۸-۳: هوک‌های ناوبری دستوری (`useRouter`, `useLocalSearchParams`, `usePathname`)

- علاوه بر ناوبری اعلانی با **`Link`**, **Expo Router** هوک‌هایی را برای **ناوبری دستوری (Programmatic Navigation)** از داخل کد فراهم می‌کند. این هوک‌ها برای سناریوهایی که ناوبری بعد از یک عملیات (مانند ارسال فرم یا پاسخ **API**) اتفاق می‌افتد، بسیار مفید هستند.

1.  **هوک `useRouter`:**
    - این هوک، ابزار اصلی شما برای جابجایی بین صفحات به صورت برنامه‌نویسی است.
    - `router.push('/path')`: یک صفحه جدید را روی پشته (**stack**) قرار می‌دهد. کاربر می‌تواند با دکمه بازگشت به صفحه قبلی بازگردد.
    - `router.replace('/path')`: صفحه فعلی را با یک صفحه جدید **جایگزین** می‌کند. کاربر نمی‌تواند به صفحه قبلی بازگردد. این هوک برای سناریوهایی مانند بعد از لاگین کردن کاربر بسیار مفید است.
    - `router.back()`: به صفحه قبلی در پشته ناوبری بازمی‌گردد.

*توجه: مثال کد برای `useRouter` در منابع ارائه نشده است.*

2.  **هوک `useLocalSearchParams`:**
    - این هوک برای **خواندن پارامترهای داینامیک** از **URL** **صفحه فعلی** استفاده می‌شود.
    - **کاربرد:** اگر شما یک مسیر داینامیک مانند `app/user/[id].tsx` (که `[id]` یک پارامتر است) داشته باشید و کاربر به آدرس `/user/123` برود، هوک `useLocalSearchParams` یک آبجکت به شکل `{ id: '123' }` را برمی‌گرداند. این به شما اجازه می‌دهد تا داده‌های مربوط به آن `id` را از سرور دریافت و نمایش دهید.
    - **مثال (در فایل `app/user/[id].tsx`):**
    ```javascript
    import { useLocalSearchParams } from 'expo-router';
    import { Text } from 'react-native';

    export default function UserProfile() {
      const { id } = useLocalSearchParams<{ id: string }>(); // نوع‌دهی برای TypeScript
      return <Text>پروفایل کاربر با شناسه: {id}</Text>;
    }
    ```

3.  **هوک `usePathname`:**
    - این یک هوک ساده است که **آدرس مسیر فعلی** را به صورت یک رشته برمی‌گرداند (مثلاً `/user/123`).
    - **کاربرد:** برای هایلایت کردن لینک فعال در یک منوی ناوبری سفارشی یا برای ارسال آدرس فعلی صفحه به سرویس‌های آنالیتیکس (**Analytics**) مفید است.

*توجه: مثال کد برای `usePathname` در منابع ارائه نشده است.*

---

## فصل ۹: ارتباط با دنیای خارج: شبکه (Networking)

- تقریباً تمام اپلیکیشن‌های مدرن موبایل نیاز به ارتباط با دنیای خارج دارند؛ یعنی برای دریافت و ارسال داده به سرورها از طریق اینترنت با **API**ها تعامل می‌کنند.
- در این فصل، با روش‌های مختلف برقراری ارتباط شبکه در **React Native** آشنا می‌شویم.

### ۹-۱: `Fetch API`

- **React Native** به صورت داخلی از **Fetch API** پشتیبانی می‌کند.
- این یک استاندارد مدرن وب برای ارسال درخواست‌های شبکه (مانند `GET, POST, PUT, DELETE`) است.
- **Fetch API** مبتنی بر **Promise** است و به خوبی با ساختار `async/await` در جاوااسکریپت کار می‌کند، که کد را خواناتر و مدیریت خطا را آسان‌تر می‌کند.

- **مثال ساده `Fetch`:**

```javascript
const fetchData = async () => {
  try {
    const response = await fetch('https://api.example.com/data');
    const json = await response.json();
    console.log(json);
  } catch (error) {
    console.error('خطا در دریافت داده:', error);
  }
};
```

### ۹-۲: گردش کار دریافت داده (الگوی کلاسیک)

- این الگو از هوک‌های `useEffect` و `useState` برای مدیریت چرخه حیات داده در کامپوننت‌های تابعی استفاده می‌کند.
- این روش رایج‌ترین الگوی دریافت داده قبل از **React 19** بود و هنوز هم در بسیاری از پروژه‌ها استفاده می‌شود.

- **مراحل اصلی:**
    1.  **تعریف State ها:** سه **state** مجزا برای نگهداری وضعیت‌های مختلف تعریف می‌کنیم:
        - `data`: برای ذخیره داده‌های دریافتی موفقیت‌آمیز.
        - `isLoading`: یک مقدار `boolean` برای نمایش وضعیت بارگذاری (مثلاً نمایش یک `Spinner`).
        - `error`: برای ذخیره هرگونه خطای احتمالی در حین فرایند دریافت داده.
    2.  **ارسال درخواست در `useEffect`:** درخواست `fetch` را داخل یک هوک `useEffect` قرار می‌دهیم. برای اطمینان از اینکه درخواست **فقط یک بار** هنگام باز شدن صفحه (یا `mount` شدن کامپوننت) اجرا شود، آرایه وابستگی (**Dependency Array**) هوک `useEffect` را **خالی (`[]`)** قرار می‌دهیم.
    3.  **مدیریت پاسخ (`Try...Catch...Finally`):** از یک بلاک `try...catch...finally` برای مدیریت نتایج درخواست استفاده می‌کنیم:
        - در بلاک `try`: داده‌های دریافتی را به فرمت **JSON** تبدیل کرده و آن‌ها را در **state** مربوط به `data` قرار می‌دهیم.
        - در بلاک `catch`: هر خطایی که در طول درخواست یا پردازش رخ دهد را دریافت کرده و آن را در **state** مربوط به `error` ذخیره می‌کنیم.
        - در بلاک `finally`: وضعیت `isLoading` را به `false` تغییر می‌دهیم تا نشان دهیم که عملیات بارگذاری به پایان رسیده است، چه با موفقیت و چه با خطا.
    4.  **رندر شرطی:** در رابط کاربری (**UI**)، بر اساس مقادیر `isLoading` و `error`، یک نمایشگر لودینگ، پیام خطا یا لیست داده‌های دریافتی را به کاربر نمایش می‌دهیم.

- **مثال:**

```javascript
import React, { useState, useEffect } from 'react';
import { View, Text, ActivityIndicator, StyleSheet } from 'react-native';

export default function DataFetcherClassic() {
  const [data, setData] = useState(null); // داده‌های دریافت شده
  const [isLoading, setIsLoading] = useState(true); // وضعیت لودینگ
  const [error, setError] = useState(null); // خطاهای احتمالی

  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await fetch('https://jsonplaceholder.typicode.com/todos/1');
        if (!response.ok) {
          throw new Error('خطا در شبکه');
        }
        const json = await response.json();
        setData(json); // ذخیره داده‌ها
      } catch (err) {
        setError(err.message); // ذخیره خطا
      } finally {
        setIsLoading(false); // پایان لودینگ
      }
    };
    fetchData();
  }, []); // درخواست فقط یک بار اجرا می‌شود

  if (isLoading) {
    return (
      <View style={styles.container}>
        <ActivityIndicator size="large" color="#0000ff" />
        <Text>در حال بارگذاری...</Text>
      </View>
    );
  }

  if (error) {
    return (
      <View style={styles.container}>
        <Text style={styles.errorText}>خطا: {error}</Text>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <Text style={styles.title}>داده دریافت شده:</Text>
      <Text>شناسه کاربر: {data.userId}</Text>
      <Text>شناسه: {data.id}</Text>
      <Text>عنوان: {data.title}</Text>
      <Text>تکمیل شده: {data.completed ? 'بله' : 'خیر'}</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, justifyContent: 'center', alignItems: 'center', padding: 20 },
  title: { fontSize: 20, fontWeight: 'bold', marginBottom: 10 },
  errorText: { color: 'red', fontSize: 18 },
});
```

### ۹-۳: گردش کار مدرن با React 19 (`use` و `Suspense`)

- با پشتیبانی **Expo** از **React 19** (یا نسخه‌های بالاتر که این ویژگی‌ها را دارند)، می‌توانیم فرآیند دریافت داده را بسیار ساده‌تر و بهینه‌تر کنیم.
- این رویکرد جدید از هوک `use` و کامپوننت `Suspense` بهره می‌برد.
- این الگو نیاز به مدیریت **state**های لودینگ و خطا را در هر کامپوننت از بین می‌برد.

- **هوک `use`:**
    - این هوک انقلابی به ما اجازه می‌دهد تا **نتیجه یک Promise را مستقیماً "باز" (unwrap) کنیم**.
    - دیگر نیازی به `useEffect` و `useState` برای مدیریت چرخه حیات درخواست نیست.
    - این هوک فقط در کامپوننت‌های سمت سرور (**Server Components**) یا کامپوننت‌هایی که با `Suspense` پیچیده شده‌اند قابل استفاده است.
- **`Suspense`:**
    - این کامپوننت به ما اجازه می‌دهد تا یک **UI جایگزین (fallback)** (مانند `ActivityIndicator` یا یک **skeleton UI**) را نمایش دهیم.
    - این **fallback UI** تا زمانی که داده‌های کامپوننت فرزند آماده شوند، به کاربر نمایش داده می‌شود.
    - این یک راه بسیار تمیز برای مدیریت وضعیت‌های لودینگ در سطح کامپوننت است.
    - این جداسازی منطق بارگذاری از منطق نمایش داده‌ها، کد را خواناتر و ماژولارتر می‌کند.

- **مثال:**

```javascript
// کامپوننت والد (ParentComponent)
import { Suspense } from 'react';
import { View, Text, ActivityIndicator } from 'react-native';

function ParentComponent() {
  return (
    <Suspense fallback={
      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
        <ActivityIndicator size="large" color="#0000ff" />
        <Text>در حال بارگذاری داده...</Text>
      </View>
    }> {/* نمایش UI جایگزین تا زمانی که داده‌های فرزند آماده شوند */}
      <MyDataComponent /> {/* کامپوننت فرزند که از هوک use استفاده می‌کند */}
    </Suspense>
  );
}

// کامپوننت فرزند (MyDataComponent)
import { use } from 'react';

const fetchMyData = () =>
  fetch('https://jsonplaceholder.typicode.com/todos/1').then(res => res.json()); // تابع دریافت داده که یک Promise برمی‌گرداند

function MyDataComponent() {
  // دیگر نیازی به بررسی isLoading و error نیست، Suspense آن را مدیریت می‌کند
  const data = use(fetchMyData()); // مستقیم از Promise باز می‌شود

  return (
    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center', padding: 20 }}>
      <Text style={{ fontSize: 20, fontWeight: 'bold', marginBottom: 10 }}>داده دریافت شده:</Text>
      <Text>عنوان: {data.title}</Text>
      <Text>وضعیت: {data.completed ? 'تکمیل شده' : 'در حال انجام'}</Text>
    </View>
  );
}

export default ParentComponent;
```

- **توضیح:** در این رویکرد، `ParentComponent` با استفاده از `<Suspense>`، یک **UI** جایگزین (لودینگ اسپینر) را نمایش می‌دهد تا `MyDataComponent` داده‌های خود را با `use(fetchMyData())` دریافت کند. وقتی داده‌ها آماده شدند، `<Suspense>` به طور خودکار `MyDataComponent` را رندر می‌کند. این امر کد را به شدت تمیزتر می‌کند و منطق بارگذاری را از منطق نمایش جدا می‌سازد.
- برای مدیریت خطاها در این سناریو، باید از **Error Boundaries** استفاده کنید (خارج از محدوده این منبع).

---

## فصل ۱۰: حافظه پایدار: ذخیره‌سازی داده‌ها

- اغلب نیاز داریم اطلاعات را روی دستگاه کاربر ذخیره کنیم تا با بسته و باز شدن اپلیکیشن، این اطلاعات از بین نروند.
- این فصل شما را با ابزارهای اصلی برای ذخیره‌سازی داده‌ها در **React Native**، از اطلاعات ساده تا داده‌های حساس و پیچیده، آشنا می‌کند.

### ۱۰-۱: AsyncStorage - انبار ساده کلید-مقدار

- **AsyncStorage** استاندارد اصلی برای ذخیره داده‌های **ساده و غیرحساس** در **React Native** است.
- عملکردی شبیه به `localStorage` در وب دارد، اما به صورت ناهمزمان (**Asynchronous**) عمل می‌کند.
- **ساختار:** داده‌ها به صورت **کلید-مقدار (Key-Value)** ذخیره می‌شوند. هم کلید و هم مقدار باید به صورت **رشته (string)** باشند.
- **برای ذخیره آبجکت‌ها:** باید ابتدا آن‌ها را با `JSON.stringify()` به رشته تبدیل کنید و هنگام بازیابی با `JSON.parse()` به آبجکت اصلی برگردانید.
- **کاربرد:** ذخیره تنظیمات کاربر (مانند تم برنامه، زبان)، نام کاربری، یا وضعیت‌های کوچک.
- **نصب:** `npx expo install @react-native-async-storage/async-storage`

- **مثال:**

```javascript
import AsyncStorage from '@react-native-async-storage/async-storage';

const saveItem = async (key, value) => {
  try {
    await AsyncStorage.setItem(key, value);
    console.log('داده ذخیره شد!');
  } catch (e) {
    console.error('خطا در ذخیره داده:', e);
  }
};

const getItem = async (key) => {
  try {
    const value = await AsyncStorage.getItem(key);
    if (value !== null) {
      console.log('داده خوانده شد:', value);
      return value;
    }
  } catch (e) {
    console.error('خطا در خواندن داده:', e);
  }
  return null;
};

// ذخیره یک آبجکت
const saveObject = async (key, obj) => {
  try {
    const jsonValue = JSON.stringify(obj);
    await AsyncStorage.setItem(key, jsonValue);
  } catch (e) {
    console.error('خطا در ذخیره آبجکت:', e);
  }
};

// خواندن یک آبجکت
const getObject = async (key) => {
  try {
    const jsonValue = await AsyncStorage.getItem(key);
    return jsonValue != null ? JSON.parse(jsonValue) : null;
  } catch (e) {
    console.error('خطا در خواندن آبجکت:', e);
  }
};
```

### ۱۰-۲: SecureStore - گاوصندوق اطلاعات حساس

- برای ذخیره اطلاعات **حساس** که نباید به راحتی قابل خواندن باشند (حتی با دسترسی مستقیم به فایل‌های دستگاه)، از ماژول `expo-secure-store` استفاده می‌کنیم.
- **امنیت:** این ماژول از قابلیت‌های امنیتی خود سیستم‌عامل (**Keychain** در iOS و **Keystore** در Android) برای **رمزنگاری داده‌ها** استفاده می‌کند. این به این معنی است که داده‌ها به صورت امن در محل مخصوص سیستم‌عامل ذخیره می‌شوند و دسترسی به آن‌ها بدون احراز هویت مناسب بسیار دشوار است.
- **کاربرد:** ذخیره توکن‌های احراز هویت (**JWT**), کلیدهای **API** خصوصی، و رمزهای عبور.
- **نصب:** `npx expo install expo-secure-store`

- **مثال:**

```javascript
import * as SecureStore from 'expo-secure-store';

const saveSecureValue = async (key, value) => {
  try {
    await SecureStore.setItemAsync(key, value);
    console.log('مقدار امن ذخیره شد!');
  } catch (e) {
    console.error('خطا در ذخیره مقدار امن:', e);
  }
};

const getSecureValue = async (key) => {
  try {
    const value = await SecureStore.getItemAsync(key);
    if (value) {
      console.log('مقدار امن خوانده شد:', value);
      return value;
    }
  } catch (e) {
    console.error('خطا در خواندن مقدار امن:', e);
  }
  return null;
};
```

### ۱۰-۳: SQLite - دیتابیس رابطه‌ای

- برای مدیریت داده‌های **حجیم، پیچیده و رابطه‌ای** که نیاز به کوئری‌های پیشرفته و عملکرد بالا در حالت آفلاین دارند، به یک دیتابیس واقعی روی دستگاه نیاز داریم.
- `expo-sqlite` یک پیاده‌سازی از دیتابیس محبوب **SQLite** را فراهم می‌کند. این دیتابیس به صورت یک فایل روی دستگاه کاربر ذخیره می‌شود.
- **کاربرد:** ساخت اپلیکیشن‌هایی که باید به صورت آفلاین به خوبی کار کنند، اپ‌های مدیریت وظایف، یا هر برنامه‌ای با داده‌های ساختاریافته که نیاز به جستجو و فیلترهای پیچیده دارند.
- **نصب:** `npx expo install expo-sqlite`

- **مثال (ایجاد دیتابیس و جدول):**

```javascript
import * as SQLite from 'expo-sqlite';

const db = SQLite.openDatabase('myDatabase.db');

const initDatabase = () => {
  db.transaction(tx => {
    tx.executeSql(
      'CREATE TABLE IF NOT EXISTS items (id INTEGER PRIMARY KEY NOT NULL, name TEXT NOT NULL);',
      [],
      () => console.log('جدول ساخته شد یا از قبل وجود داشت.'),
      (_, error) => console.error('خطا در ساخت جدول:', error)
    );
  });
};

// فراخوانی در ابتدای برنامه
// initDatabase();
```

---

## فصل ۱۱: روح بخشیدن به اپ: انیمیشن و جسچرها

- انیمیشن‌های روان و بازخوردهای لمسی جذاب، تجربه کاربری (**UX**) را به سطح دیگری می‌برند و اپلیکیشن شما را زنده و پویاتر می‌کنند.
- در این فصل، با استفاده از کتابخانه‌های قدرتمند **React Native Reanimated** و `react-native-gesture-handler`، یاد می‌گیریم چگونه انیمیشن‌های پیشرفته و تعاملات لمسی پیچیده را پیاده‌سازی کنیم.

### ۱۱-۱: انیمیشن با React Native Reanimated

- **React Native Reanimated** کتابخانه استاندارد و مدرن برای پیاده‌سازی انیمیشن‌های با عملکرد بالا در **React Native** است.
- دلیل اصلی برتری آن این است که منطق انیمیشن را مستقیماً روی **نخ UI (Main Thread)** اجرا می‌کند. این کار باعث می‌شود انیمیشن‌ها حتی زمانی که نخ جاوااسکریپت مشغول است، به صورت **روان و ۶۰ فریم بر ثانیه** اجرا شوند. این از گیر کردن انیمیشن‌ها هنگام پردازش‌های سنگین در نخ **JS** جلوگیری می‌کند.

- **مفاهیم اصلی:**
    - **`useSharedValue`**: این هوک برای تعریف مقادیری استفاده می‌شود که قرار است **انیمیت شوند**. مانند `useState` عمل می‌کند، اما مقدار ذخیره شده در آن بین نخ **JS** و نخ **UI** "به اشتراک گذاشته" می‌شود. تغییر این مقادیر مستقیماً در نخ **UI** اعمال می‌شود.
    - **`useAnimatedStyle`**: این هوک یک آبجکت استایل انیمیشنی را برمی‌گرداند که به مقادیر اشتراکی (`Shared Values`) شما متصل است. هر زمان که مقدار اشتراکی تغییر کند، استایل مربوطه به صورت انیمیت شده به‌روزرسانی می‌شود. این هوک یک آبجکت استایل برمی‌گرداند که می‌توانید آن را به کامپوننت‌های **Animated** خود بدهید.
    - **`Animated.View`، `Animated.Text` و `Animated.Image`**: نسخه‌های انیمیشنی کامپوننت‌های اصلی **React Native** هستند. شما باید کامپوننت‌هایی را که می‌خواهید انیمیت کنید، به این نسخه‌های **Animated** تبدیل کنید تا بتوانند استایل‌های انیمیشنی را دریافت کنند.
    - **`withTiming` و `withSpring`**: این توابع به **Reanimated** می‌گویند که یک مقدار را **چگونه** انیمیت کند.
        - `withTiming(toValue, config)`: یک انیمیشن مبتنی بر **زمان** (**Duration**) ایجاد می‌کند. برای انیمیشن‌های با مدت زمان مشخص و منحنی (`easing`).
        - `withSpring(toValue, config)`: یک انیمیشن **فنری** و طبیعی ایجاد می‌کند که حالت ارتداد (**Bouncy**) دارد.

- **نصب:**
    - پس از نصب، باید `plugins: ['react-native-reanimated/plugin']` را به فایل `babel.config.js` خود اضافه کرده و سرور **Metro** را ریستارت کنید.

- **مثال (یک `View` که با کلیک کردن اندازه آن تغییر می‌کند):**

```javascript
import React from 'react';
import { Button, StyleSheet, View } from 'react-native';
import Animated, { useSharedValue, useAnimatedStyle, withTiming } from 'react-native-reanimated';

export default function ReanimatedExample() {
  const width = useSharedValue(100); // تعریف یک Shared Value

  const animatedStyle = useAnimatedStyle(() => {
    return {
      width: withTiming(width.value, { duration: 500 }), // انیمیت کردن عرض با زمان‌بندی
    };
  });

  const handlePress = () => {
    width.value = width.value === 100 ? 200 : 100; // تغییر مقدار Shared Value
  };

  return (
    <View style={styles.container}>
      <Animated.View style={[styles.box, animatedStyle]} />
      <Button onPress={handlePress} title="تغییر اندازه جعبه" />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  box: {
    height: 100,
    backgroundColor: 'red',
    margin: 50,
  },
});
```

### ۱۱-۲: کار با حرکات لمسی (Gestures)

- برای مدیریت حرکات لمسی پیچیده مانند کشیدن (**Drag**), زوم کردن، یا چرخاندن، ما از کتابخانه **`react-native-gesture-handler`** در ترکیب با **Reanimated** استفاده می‌کنیم.
- این کتابخانه‌ها به ما اجازه می‌دهند که حرکات لمسی را به صورت بومی و با عملکرد بالا پردازش کنیم. این ترکیب به شما امکان می‌دهد جسچرهای پیچیده را تعریف کنید و انیمیشن‌های مربوطه را مستقیماً روی نخ **UI** اجرا کنید.

- **API مدرن:**
    - به جای هوک‌های قدیمی، از آبجکت **`Gesture`** برای تعریف نوع حرکت (مثلاً `Gesture.Pan()` برای کشیدن، `Gesture.Tap()` برای ضربه) و از کامپوننت **`<GestureDetector>`** برای اعمال آن به یک عنصر استفاده می‌کنیم.
    - این باعث می‌شود تعریف جسچرها بسیار تمیزتر و ماژولارتر باشد.

- **Worklets:**
    - توابعی که قرار است در پاسخ به جسچرها روی نخ **UI** اجرا شوند، باید با دستورالعمل `"worklet";` در ابتدای آن‌ها مشخص شوند.
    - این دستورالعمل به باندلر می‌گوید که این تابع را برای اجرا در محیط **Reanimated** آماده کند و از کرش کردن برنامه جلوگیری می‌کند.

- **نصب:**
    - پس از نصب `react-native-gesture-handler`، باید آن را در `entry-point` اصلی برنامه (معمولا `index.js` یا `App.js`) ایمپورت کنید: `import 'react-native-gesture-handler';`.

- **مثال (کشیدن یک جعبه):**

```javascript
import React from 'react';
import { StyleSheet, View } from 'react-native';
import { GestureDetector, Gesture } from 'react-native-gesture-handler';
import Animated, { useAnimatedStyle, useSharedValue } from 'react-native-reanimated';

export default function DraggableBox() {
  const translateX = useSharedValue(0); // Shared Value برای موقعیت افقی
  const translateY = useSharedValue(0); // Shared Value برای موقعیت عمودی

  const panGesture = Gesture.Pan()
    .onUpdate((event) => {
      'worklet'; // اعلام Worklet
      translateX.value = event.translationX;
      translateY.value = event.translationY;
    })
    .onEnd(() => {
      'worklet'; // اعلام Worklet
      // می‌توانید اینجا جعبه را به موقعیت اولیه برگردانید یا آن را در جای جدید رها کنید
      // translateX.value = withSpring(0);
      // translateY.value = withSpring(0);
    });

  const animatedStyle = useAnimatedStyle(() => {
    return {
      transform: [
        { translateX: translateX.value },
        { translateY: translateY.value },
      ],
    };
  });

  return (
    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
      <GestureDetector gesture={panGesture}>
        <Animated.View style={[styles.box, animatedStyle]} />
      </GestureDetector>
    </View>
  );
}

const styles = StyleSheet.create({
  box: {
    width: 100,
    height: 100,
    backgroundColor: 'blue',
    borderRadius: 10,
  },
});
```

---

## فصل ۱۲: تضمین کیفیت: تست‌نویسی (Testing)

- نوشتن تست‌های خودکار (**Automated Tests**) یک بخش حیاتی از فرآیند توسعه نرم‌افزار حرفه‌ای است.
- تست‌ها تضمین می‌کنند که اپلیکیشن شما در طول زمان باکیفیت، پایدار و بدون باگ‌های ناخواسته باقی بماند، حتی با اضافه شدن ویژگی‌های جدید.
- این فصل، شما را با سه نوع اصلی تست‌نویسی در **React Native** آشنا می‌کند.

### ۱۲-۱: تست واحد (Unit Testing)

- **هدف:** تست واحد بر **کوچکترین واحد کد** (معمولاً یک تابع خالص یا یک ماژول کوچک) تمرکز دارد.
- این تست‌ها اطمینان می‌دهند که هر بخش از کد به درستی کار می‌کند، مستقل از بقیه سیستم.
- **ابزار:** **Jest**. این فریم‌ورک تست جاوااسکریپت است که توسط فیس‌بوک (توسعه‌دهنده **React Native**) ساخته شده است. **Jest** به طور پیش‌فرض در پروژه‌های **Expo** پیکربندی شده است و یک ابزار قدرتمند برای تست جاوااسکریپت است.

- **مثال (تست یک تابع جمع):**

```javascript
// functions.js
export function sum(a, b) {
  return a + b;
}

// functions.test.js
import { sum } from './functions';

test('sum adds 1 + 2 to equal 3', () => {
  expect(sum(1, 2)).toBe(3);
});
```

- برای اجرای تست‌ها: `npm test` یا `yarn test`.

### ۱۲-۲: تست کامپوننت (Component Testing)

- **هدف:** تست کامپوننت بر تست کردن **یک کامپوننت React به تنهایی** تمرکز دارد.
- این تست‌ها بررسی می‌کنند که آیا کامپوننت به درستی رندر می‌شود، ورودی‌ها (**پراپ‌ها**) را به درستی دریافت می‌کند و به تعاملات کاربر (مانند کلیک کردن روی دکمه‌ها یا وارد کردن متن) واکنش صحیح نشان می‌دهد.
- این تست‌ها بر خروجی **UI** و رفتار کامپوننت تمرکز دارند، نه بر جزئیات پیاده‌سازی داخلی.
- **ابزار:** **React Native Testing Library**. این کتابخانه بر اساس فلسفه "تست بر اساس نحوه استفاده کاربر" بنا شده است و یک رویکرد کاربر-محور برای تست کامپوننت‌ها را ترویج می‌کند. به شما کمک می‌کند تا تست‌هایی بنویسید که شبیه به تعاملات واقعی کاربر با **UI** باشند.

- **نصب:**
    - `npm install --save-dev @testing-library/react-native` (یا `yarn add --dev ...`)

- **مثال (تست یک کامپوننت ساده دکمه):**

```javascript
// MyButton.js
import React from 'react';
import { Button } from 'react-native';

export default function MyButton({ onPress, title }) {
  return <Button onPress={onPress} title={title} />;
}

// MyButton.test.js
import React from 'react';
import { render, fireEvent } from '@testing-library/react-native';
import MyButton from './MyButton';

test('renders correctly and calls onPress', () => {
  const mockOnPress = jest.fn();
  const { getByText } = render(<MyButton onPress={mockOnPress} title="کلیک کن" />);
  const button = getByText('کلیک کن');
  fireEvent.press(button);
  expect(mockOnPress).toHaveBeenCalledTimes(1);
});
```

### ۱۲-۳: تست سرتاسری (End-to-End - E2E)

- **هدف:** تست **E2E** بر تست کردن **کل جریان کاری اپلیکیشن**، از دید یک کاربر واقعی، تمرکز دارد.
- در این نوع تست، یک ربات (یا ابزار خودکارسازی) اپلیکیشن را روی یک شبیه‌ساز واقعی یا دستگاه فیزیکی باز کرده و سناریوهای مختلف کاربر (مانند ورود، پیمایش بین صفحات، ارسال فرم) را اجرا می‌کند.
- این تست‌ها مطمئن می‌شوند که تمام بخش‌های اپلیکیشن (از **UI** تا بک‌اند) به درستی با هم کار می‌کنند.
- **ابزارها:**
    - **Maestro:** یک ابزار نسبتاً جدید و ساده‌تر برای نوشتن تست‌های **E2E** است.
    - **Detox:** یک فریم‌ورک تست **E2E** قوی‌تر و با قابلیت‌های بیشتر است.
- این تست‌ها معمولاً پیچیده‌تر هستند اما بالاترین سطح اطمینان را ارائه می‌دهند. نیاز به پیکربندی بیشتری دارد که در این بخش به جزئیات آن نمی‌پردازیم، اما درک مفهوم آن برای یک توسعه‌دهنده حرفه‌ای ضروری است.

---

## فصل ۱۳: بهینه‌سازی و عملکرد (Performance Optimization)

- عملکرد (**Performance**) یکی از مهم‌ترین جنبه‌های هر اپلیکیشن موبایل است.
- یک اپلیکیشن سریع، روان و پاسخگو، تجربه کاربری بهتری را ارائه می‌دهد و کاربران را راضی نگه می‌دارد.
- در این فصل، یاد می‌گیریم چطور اپلیکیشن خود را سریع، روان و بهینه نگه داریم تا بهترین تجربه کاربری را ارائه دهیم.

### ۱۳-۱: ابزارهای اصلی

- برای شناسایی مشکلات عملکردی در اپلیکیشن **React Native**، ابزارهای قدرتمندی در دسترس داریم:

- **Profiler در React DevTools:**
    - این ابزار، که از طریق **Flipper** قابل دسترسی است، به شما اجازه می‌دهد **عملکرد رندرینگ اپلیکیشن** را ضبط و تحلیل کنید.
    - با استفاده از **Profiler** می‌توانید ببینید کدام کامپوننت‌ها بیهوده دوباره رندر می‌شوند یا رندر آن‌ها زمان‌بر است. این ابزار به شناسایی `bottlenecks` (نقاط گلوگاهی) در رندرینگ کمک می‌کند.

- **Flipper:**
    - **Flipper** یک اپلیکیشن دسکتاپ و ابزار دیباگینگ **همه‌کاره** است که توسط فیس‌بوک توسعه یافته است.
    - این ابزار پلاگین‌های متنوعی برای بررسی جنبه‌های مختلف اپلیکیشن ارائه می‌دهد:
        - **Layout (چیدمان):** برای بررسی و تغییر چیدمان عناصر **UI** در زمان واقعی.
        - **Network (شبکه):** برای مشاهده تمام درخواست‌های شبکه و پاسخ‌های آن‌ها.
        - **Logs (لاگ‌ها):** برای مشاهده پیام‌های `console.log` و خطاها.
        - **Shared Preferences/AsyncStorage:** برای بررسی داده‌های ذخیره شده در دستگاه.
    - استفاده از **Flipper** برای دیباگینگ و مانیتورینگ عملکرد بسیار توصیه می‌شود.

### ۱۳-۲: تکنیک‌های بهینه‌سازی

- برای بهبود عملکرد اپلیکیشن، چندین تکنیک کلیدی وجود دارد:

1.  **جلوگیری از رندرهای غیرضروری:**
    - رندر شدن بیش از حد کامپوننت‌ها (حتی اگر **UI** تغییری نکرده باشد) یکی از دلایل اصلی افت عملکرد است. **React** ابزارهایی برای جلوگیری از این رندرهای اضافی ارائه می‌دهد:
        - **`React.memo`**: یک **Higher-Order Component (HOC)** است که کامپوننت‌های تابعی را **memoize** می‌کند. این کامپوننت‌ها اگر **props** آن‌ها تغییر نکرده باشد، از رندر شدن مجدد محافظت می‌شوند. اگر پراپ‌های یک کامپوننت `memoized` تغییر نکرده باشد، **React** از آخرین رندر کش شده آن استفاده می‌کند.
        - **`useCallback`**: از ساخته شدن **مجدد توابع** در هر رندر جلوگیری می‌کند. این هوک به خصوص برای توابعی که به عنوان **props** به کامپوننت‌های `memoized` پاس داده می‌شوند، مفید است تا رندر غیرضروری آن‌ها را متوقف کند.
        - **`useMemo`**: نتیجه محاسبات سنگین را در حافظه **کش** می‌کند تا از اجرای مجدد آن‌ها در هر رندر جلوگیری شود. از این هوک برای محاسباتی استفاده کنید که زمان‌بر هستند.

*توجه: مثال کد برای `React.memo`, `useCallback` و `useMemo` در منابع ارائه نشده است.*

2.  **بهینه‌سازی `FlatList`:**
    - `FlatList` به طور طبیعی بهینه است، اما پراپ‌های خاصی می‌توانند عملکرد آن را برای لیست‌های بسیار بلند بیشتر بهبود بخشند.
    - `getItemLayout`: اگر ارتفاع تمام آیتم‌های لیست ثابت است، با تعریف این پراپ می‌توانید به `FlatList` کمک کنید تا بدون نیاز به اندازه‌گیری، موقعیت و ابعاد آیتم‌ها را محاسبه کند. این به اسکرولینگ بسیار روان‌تر منجر می‌شود.
    - `initialNumToRender`: تعداد آیتم‌هایی که `FlatList` باید در ابتدا رندر کند را مشخص می‌کند. تنظیم صحیح این مقدار می‌تواند زمان بارگذاری اولیه را بهبود بخشد.

3.  **موتور Hermes:**
    - **Hermes** موتور جاوااسکریپت بهینه‌سازی شده برای **React Native** است که توسط **Meta** توسعه یافته است.
    - این موتور به طور پیش‌فرض در پروژه‌های **Expo** فعال است و باعث کاهش مصرف حافظه و افزایش سرعت بارگذاری اولیه اپلیکیشن می‌شود.
    - فعال بودن **Hermes** به طور کلی عملکرد اپلیکیشن شما را به میزان قابل توجهی بهبود می‌بخشد. مطمئن شوید که **Hermes** در پروژه شما فعال است (در `app.json` یا `app.config.js`).

---

## فصل ۱۴: گردش کار حرفه‌ای: Development Builds

- این بخش، کلید عبور از محدودیت‌های گذشته **Expo Go** و رسیدن به نهایت قدرت **Expo** است.

### ۱۴-۱: مشکل Expo Go

- اپلیکیشن **Expo Go** که برای اجرای سریع پروژه‌ها روی دستگاه‌های واقعی استفاده می‌شود، شامل مجموعه‌ای از **ماژول‌های نیتیو از پیش نصب شده** است. این ماژول‌ها کتابخانه‌های پرکاربرد **Expo** (مانند `expo-camera`, `expo-location` و غیره) را فراهم می‌کنند.

- **مشکل اینجا پیش می‌آید:** اگر شما به یک **کتابخانه نیتیو دیگری** نیاز داشته باشید که جزو ماژول‌های از پیش نصب شده در **Expo Go** نیست (مثلاً یک کتابخانه پرداخت سفارشی، `react-native-blur` یا یک **SDK** خاص)، اپلیکیشن شما در **Expo Go** **کرش می‌کند** و قابل اجرا نخواهد بود. در گذشته، برای استفاده از چنین کتابخانه‌هایی، مجبور بودید پروژه را به **React Native CLI** "Eject" کنید، که به معنای از دست دادن سادگی **Expo** و ورود به دنیای پیچیده‌تر مدیریت کدهای نیتیو بود.

### ۱۴-۲: راه حل: Development Builds

- **Development Build (بیلد توسعه)** یک نسخه کاملاً **سفارشی از اپلیکیشن Expo Go** است که **مخصوص پروژه شما** ساخته می‌شود.
- این بیلد، علاوه بر ماژول‌های پیش‌فرض **Expo**، **تمام کتابخانه‌های نیتیو دیگری که شما به پروژه خود اضافه کرده‌اید** را نیز شامل می‌شود.

- **نتیجه:** شما دیگر هیچ محدودیتی در استفاده از کتابخانه‌های اکوسیستم گسترده **React Native** ندارید و در عین حال از سادگی و سرعت توسعه **Expo** (مانند **Fast Refresh** و **Metro Bundler**) بهره‌مند می‌شوید. این به شما اجازه می‌دهد تا هر پکیج `npm` که شامل کد نیتیو است را نصب و استفاده کنید.

- **فرآیند:**
    1.  **نصب `expo-dev-client`:**
        - `npx expo install expo-dev-client`
    2.  **ساخت Development Build:** با اجرای دستور `eas build --profile development`، یک نسخه توسعه از اپلیکیشن خود می‌سازید. این دستور بیلد را در سرویس ابری **EAS** انجام می‌دهد و یک فایل `.apk` (برای اندروید) یا `.ipa` (برای iOS) به شما می‌دهد.
    3.  **استفاده:** پس از ساخت و نصب این بیلد روی دستگاه واقعی یا شبیه‌ساز، از آن به جای اپلیکیشن **Expo Go** برای توسعه روزمره خود استفاده می‌کنید. این بیلد به سرور **Metro** شما متصل می‌شود و **Fast Refresh** و سایر ابزارهای دیباگینگ همچنان کار می‌کنند.

- **خلاصه:** **Development Builds** به شما بهترین هر دو دنیا را می‌دهد: سادگی **Expo** برای توسعه سریع جاوااسکریپت، و انعطاف‌پذیری **React Native CLI** برای استفاده از هر کتابخانه نیتیوی که نیاز دارید.

---

## فصل ۱۵: از کد تا کاربر: ساخت و انتشار با EAS

- پس از اینکه اپلیکیشن خود را توسعه دادید و از کیفیت آن مطمئن شدید، گام نهایی تبدیل کد شما به یک اپلیکیشن واقعی و قابل انتشار در فروشگاه‌های اپلیکیشن (**Google Play Store** و **Apple App Store**) است.
- **Expo** به وسیله سرویس **EAS (Expo Application Services)** این فرآیند را به شدت ساده و خودکار می‌کند.

### ۱۵-۱: EAS Build

- **EAS Build** یک سرویس ابری از **Expo** است که کدهای شما را دریافت کرده و **فایل‌های نهایی اپلیکیشن** را برای پلتفرم‌های مختلف در فضای ابری برایتان می‌سازد.
- **خروجی:** برای اندروید، فایل‌های `.apk` (برای نصب مستقیم) یا `.aab` (**Android App Bundle**، فرمت توصیه شده برای انتشار در پلی استور) تولید می‌شود. برای iOS، فایل `.ipa` تولید می‌شود.

- **مزیت اصلی:** **بدون نیاز به داشتن مک برای ساخت خروجی iOS** و بدون درگیر شدن با تنظیمات پیچیده **Xcode** و **Android Studio**. **EAS Build** تمام فرآیند کامپایل نیتیو را در سرورهای خود انجام می‌دهد.

- **دستور:**
    - `eas build --platform all` (برای ساخت بیلد برای هر دو پلتفرم)
    - شما می‌توانید با `--platform android` یا `--platform ios` فقط برای یک پلتفرم خاص بیلد بگیرید.

### ۱۵-۲: EAS Update (آپدیت هوایی - OTA)

- **EAS Update** یکی از قدرتمندترین قابلیت‌های **Expo** است.
- این ویژگی به شما اجازه می‌دهد تا **تمام تغییرات جاوااسکریپت** (مانند اصلاح باگ‌ها، تغییرات ظاهری، به‌روزرسانی‌های منطق برنامه) را **بدون نیاز به انتشار نسخه جدید در اپ استورها**، مستقیماً برای کاربران خود ارسال کنید.

- **نحوه کار:** **EAS Update** یک بسته جاوااسکریپت جدید تولید می‌کند و آن را روی **CDN** (شبکه توزیع محتوا) میزبانی می‌کند. اپلیکیشن‌های کاربران شما در پس‌زمینه این به‌روزرسانی‌ها را دریافت کرده و در اجرای بعدی یا پس از چند دقیقه آن‌ها را اعمال می‌کنند.
- **اهمیت:** این ویژگی می‌تواند زمان انتشار به‌روزرسانی‌ها را از چند روز/هفته به **چند دقیقه** کاهش دهد و برای رفع سریع باگ‌ها یا اعمال تغییرات کوچک بسیار حیاتی است.
- **دستور:** `eas update`

### ۱۵-۳: EAS Submit

- **EAS Submit** یک سرویس دیگر از **EAS** است که فرآیند **آپلود کردن فایل نهایی اپلیکیشن** (که توسط **EAS Build** تولید شده) به **Google Play Console** (برای اندروید) و **App Store Connect** (برای iOS) را به صورت خودکار و از طریق خط فرمان انجام می‌دهد.
- **مزیت:** این کار باعث صرفه‌جویی زیادی در زمان و کاهش خطاهای انسانی در فرآیند انتشار می‌شود. نیاز به آپلود دستی فایل‌ها، پر کردن جزئیات و مدیریت گواهی‌ها را کاهش می‌دهد و این فرآیند اغلب پیچیده را ساده می‌کند.

- **دستور:**
    - `eas submit -p android` (برای اندروید)
    - `eas submit -p ios` (برای iOS)
- این دستورات به شما کمک می‌کنند تا بیلد نهایی را به راحتی به فروشگاه‌های مربوطه ارسال کنید.
