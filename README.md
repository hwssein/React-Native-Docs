# کتاب آموزشی: از صفر تا قهرمانی با React Native و Expo

---

## مقدمه

به دنیای هیجان‌انگیز توسعه اپلیکیشن موبایل با React Native و Expo خوش آمدید! این کتاب، راهنمای جامع شما برای ساخت اپلیکیشن‌های موبایل قدرتمند و زیبا برای هر دو پلتفرم iOS و Android است. در این مسیر، شما با مفاهیم بنیادی، کامپوننت‌های ضروری، و ابزارهای پیشرفته‌ای آشنا خواهید شد که توسعه را لذت‌بخش و کارآمد می‌سازند. هدف ما این است که شما را از یک توسعه‌دهنده تازه‌کار به یک متخصص در زمینه React Native و Expo تبدیل کنیم، به گونه‌ای که بتوانید هر ایده‌ای را به یک اپلیکیشن واقعی، باکیفیت و قابل انتشار تبدیل کنید.

آماده باشید تا دانش React و جاوااسکریپت خود را به دنیای موبایل بیاورید و اپلیکیشن‌هایی خلق کنید که تجربه کاربری نیتیو را ارائه می‌دهند.

***

## فصل ۱: خوش آمدگویی به دنیای React Native

در این فصل، شما با هسته فلسفه React Native، نحوه کارکرد آن در پشت صحنه، و مهم‌ترین تصمیم اولیه برای شروع پروژه‌هایتان آشنا خواهید شد.

### ۱-۱: فلسفه اصلی React Native

• **React Native** یک فریم‌ورک متن-باز است.
• این فریم‌ورک به شما اجازه می‌دهد با استفاده از دانش **React** و زبان **جاوااسکریپت**، اپلیکیشن‌های موبایل کاملاً **نیتیو (Native)** برای پلتفرم‌های iOS و Android بسازید.
• **نکته کلیدی و وجه تمایز اصلی React Native** این است که بر خلاف ابزارهایی که یک وب‌سایت را در قاب اپلیکیشن نمایش می‌دهند (**WebView**)، کدهای شما به عناصر واقعی و بومی رابط کاربری در هر پلتفرم ترجمه می‌شوند.
• این معماری باعث می‌شود عملکرد، ظاهر و حس اپلیکیشن شما دقیقاً مانند اپلیکیشنی باشد که با زبان‌های اصلی آن پلتفرم (مانند **Swift** برای iOS یا **Kotlin** برای Android) نوشته شده است.
• به عنوان مثال:
    • ` در کد شما، به `UIView` در iOS و `ViewGroup` در Android تبدیل می‌شود.
    • ` در کد شما، به `UITextView` در iOS و `TextView` در Android تبدیل می‌شود.

### ۱-۲: معماری درونی: نخ JS و نخ UI

یک اپلیکیشن **React Native** در دو "قلمرو" یا **Thread (نخ)** اصلی فعالیت می‌کند:
• **نخ جاوااسکریپت (JS Thread):**
    • تمام کدهای **React** شما، منطق برنامه، مدیریت **state** و فراخوانی **API**ها در این نخ اجرا می‌شود.
    • این نخ مسئول "فکر کردن" و پردازش منطق برنامه است.
• **نخ اصلی/UI (Main/UI Thread):**
    • این نخ مسئولیت تمام کارهای بصری را بر عهده دارد.
    • رندر کردن پیکسل‌ها روی صفحه و پاسخ به ژست‌های لمسی کاربر در این نخ انجام می‌شود.
    • این نخ باید همیشه آزاد و سریع باشد تا کاربر احساس کندی یا لگ نکند.
• این دو نخ از طریق یک مکانیزم ارتباطی مدرن به نام **JSI (JavaScript Interface)** با هم صحبت می‌کنند.
• **JSI** به جاوااسکریپت اجازه می‌دهد مستقیماً به اشیاء و توابع نیتیو دسترسی داشته باشد.

### ۱-۳: انتخاب مسیر: Expo در مقابل React Native CLI

این مهم‌ترین تصمیم در ابتدای هر پروژه **React Native** است.

• **Expo:**
    • یک فریم‌ورک و مجموعه‌ای از ابزارهاست که روی **React Native** ساخته شده تا فرآیند توسعه را ساده‌تر کند.
    • با **Expo** نیازی به نصب **Xcode** یا **Android Studio** برای شروع ندارید.
    • به مجموعه‌ای عظیم از کتابخانه‌های آماده دسترسی دارید.
    • سرویس ابری **EAS** نیز فرآیند ساخت و انتشار را به شدت ساده می‌کند.
    • **این مسیر پیشنهادی برای ۹۹٪ پروژه‌هاست**.

• **React Native CLI:**
    • این روش "خالص" و مستقیم استفاده از **React Native** است.
    • به شما کنترل کامل روی تمام جنبه‌های نیتیو پروژه را می‌دهد.
    • اما راه‌اندازی و نگهداری آن پیچیده‌تر است.

در این دوره، ما مسیر **Expo** را به عنوان استاندارد مدرن و کارآمد دنبال خواهیم کرد.

***

## فصل ۲: راه‌اندازی و گردش کار توسعه

در این فصل، شما یاد می‌گیرید چگونه محیط توسعه خود را راه‌اندازی کنید، اپلیکیشن را اجرا کنید، و از ابزارهای اشکال‌زدایی برای توسعه کارآمد بهره ببرید.

### ۲-۱: راه‌اندازی محیط

برای ساخت یک پروژه خام (**Blank**) با **Expo** که به طور پیش‌فرض از **TypeScript** استفاده می‌کند، از این دستور استفاده کنید:

```bash
npx create-expo-app YourProjectName
```
پس از ساخت پروژه، با دستورات زیر به پوشه پروژه بروید و سرور توسعه (**Metro**) را اجرا کنید:

```bash
cd YourProjectName
npm start
```

### ۲-۲: اجرای اپلیکیشن

شما دو راه اصلی برای دیدن نتیجه کدهای خود دارید:

1.  **دستگاه واقعی (پیشنهادی):**
    • اپلیکیشن **Expo Go** را روی گوشی خود نصب کنید.
    • **QR Code** نمایش داده شده در ترمینال را اسکن کنید.
    • (مطمئن شوید کامپیوتر و گوشی به یک شبکه **Wi-Fi** متصل هستند).

2.  **شبیه‌ساز (Simulator/Emulator):**
    • با نصب **Xcode** (برای iOS) یا **Android Studio** (برای Android)، می‌توانید یک گوشی را روی کامپیوتر خود شبیه‌سازی کرده و اپلیکیشن را روی آن اجرا کنید.

### ۲-۳: ابزارهای اشکال‌زدایی (Debugging)

**React Native** و **Expo** ابزارهای قدرتمندی برای اشکال‌زدایی ارائه می‌دهند:

• **منوی توسعه‌دهنده (Developer Menu):**
    • با تکان دادن دستگاه واقعی باز می‌شود.
    • یا با کلیدهای میانبر در شبیه‌ساز (`Ctrl+Cmd+Z` در iOS یا `Ctrl+M` در ویندوز/لینوکس).

• **Fast Refresh:**
    • با ذخیره کردن کد، تغییرات به صورت آنی و بدون از دست رفتن وضعیت (**state**) فعلی اپلیکیشن، روی صفحه اعمال می‌شود.
    • این ویژگی تجربه توسعه را بسیار سریع‌تر می‌کند.

• **LogBox:**
    • خطاهای جدی را در یک صفحه قرمز (**RedBox**) نمایش می‌دهد.
    • هشدارها را در یک کادر زرد (**YellowBox**) در پایین صفحه نمایش می‌دهد.
    • این به شما کمک می‌کند مشکلات را به سرعت شناسایی کنید.

• **Element Inspector:**
    • به شما اجازه می‌دهد روی هر عنصر **UI** کلیک کرده و اطلاعات استایل و چیدمان آن را بررسی کنید.
    • شبیه به **Developer Tools** مرورگرها برای وب است.

***

## فصل ۳: آجرهای ساختمان: کامپوننت‌های اصلی (بخش اول)

در این فصل، با اساسی‌ترین کامپوننت‌های **React Native** آشنا می‌شویم که برای ساخت رابط کاربری (UI) اپلیکیشن‌های موبایل ضروری هستند.

### ۳-۱: `View` - ظرف اصلی چیدمان

• ` بنیادی‌ترین کامپوننت برای ساخت **UI** است.
• **معادل وب:** `
• **کاربرد:**
    • به عنوان یک کانتینر برای گروه‌بندی و چیدمان کامپوننت‌های دیگر استفاده می‌شود.
    • یک ` به خودی خود دیده نمی‌شود، مگر اینکه به آن استایل بدهید.
    • این کامپوننت، بستر اصلی پیاده‌سازی **Flexbox** است.

### ۳-۲: `Text` - تنها راه نمایش متن

• یک قانون بسیار مهم در **React Native**: **تمام متن‌ها باید داخل یک کامپوننت ` قرار بگیرند**.
• شما نمی‌توانید متن را مستقیماً داخل یک ` بنویسید.
• **معادل وب:** ``, ``, ``
• **ویژگی:** کامپوننت‌های ` می‌توانند داخل هم قرار بگیرند (**Nest** شوند) و استایل‌ها را از والد خود به ارث ببرند.

### ۳-۳: `Image` - نمایش تصاویر

• این کامپوننت برای نمایش انواع تصاویر استفاده می‌شود.
• **پراپ اصلی: `source`**
• **تصاویر محلی:**
    • برای تصاویری که در پوشه پروژه شما قرار دارند، از `require` استفاده می‌کنیم.
    • این کار به باندلر (**Metro**) کمک می‌کند تا عکس را در بسته نهایی اپلیکیشن قرار دهد.
    • **مثال:**
    ```javascript
    <Image source={require('./assets/my-image.png')} />
    ```

• **تصاویر اینترنتی:**
    • برای عکس‌هایی که از یک **URL** بارگذاری می‌شوند، باید از یک آبجکت با کلید `uri` استفاده کنید.
    • **حتماً** `width` و `height` را در استایل مشخص کنید، در غیر این صورت تصویر نمایش داده نمی‌شود.
    • **مثال:**
    ```javascript
    <Image source={{ uri: 'https://example.com/logo.png' }} style={{ width: 200, height: 100 }} />
    ```

### ۳-۴: `TextInput` - دریافت ورودی از کاربر

• این کامپوننت برای ساختن فیلدهای ورودی متن استفاده می‌شود.
• **معادل وب:** ``
• **مهم‌ترین پراپ‌ها:**
    • `value`: برای کنترل مقدار ورودی از طریق **state**.
    • `onChangeText`: تابعی که با هر تغییر در متن ورودی فراخوانی می‌شود.
    • `placeholder`: برای نمایش متن جایگزین.
    • `keyboardType`: برای تعیین نوع کیبورد (مثلاً `numeric` یا `email-address`).
    • `secureTextEntry`: برای فیلدهای رمز عبور (متن را مخفی می‌کند).

***

## فصل ۴: آجرهای ساختمان: کامپوننت‌های اصلی (بخش دوم)

این فصل، ادامه معرفی کامپوننت‌های اصلی **React Native** است که برای ساخت یک اپلیکیشن کامل و تعاملی ضروری هستند.

### ۴-۱: `Pressable` - تعامل‌پذیری کامل

• این کامپوننت مدرن و اصلی برای مدیریت هر نوع تعامل لمسی است.
• `Pressable` یک "لفافه" (**Wrapper**) است که هر چیزی را داخلش قرار دهید، آن را قابل کلیک می‌کند.
• **پراپ‌های اصلی:**
    • `onPress`: برای کلیک کوتاه.
    • `onLongPress`: برای فشردن طولانی.
• **قابلیت کلیدی:** می‌توانید به پراپ `style` یک تابع بدهید `(style={({ pressed }) => ...})` تا بر اساس وضعیت فشرده شدن، استایل را به صورت داینامیک تغییر دهید. این به شما اجازه می‌دهد بازخوردهای بصری زیبایی را به کاربر ارائه دهید.

### ۴-۲: `Button` - دکمه ساده نیتیو

• این کامپوننت یک دکمه استاندارد سیستم‌عامل را نمایش می‌دهد.
• **تفاوت اصلی با `Pressable`:**
    • ظاهر آن کاملاً **بومی** است.
    • **قابلیت استایل‌دهی بسیار محدودی** دارد.
    • ظاهر آن در iOS و Android متفاوت خواهد بود.
• **پراپ‌های اصلی:**
    • `title`: متن دکمه.
    • `onPress`: تابع کلیک.
    • `color`: رنگ دکمه.
• **چه زمانی استفاده کنیم؟** برای کارهای سریع و موقتی مثل دکمه‌های داخل یک `Alert` مناسب است. برای ساخت دکمه‌های اصلی و با طراحی سفارشی اپلیکیشن، تقریباً همیشه از `Pressable` استفاده می‌شود.

### ۴-۳: `Modal` - نمایش محتوا روی صفحه

• کامپوننت `Modal` برای نمایش محتوا **روی** نمای اصلی اپلیکیشن استفاده می‌شود (مانند دیالوگ‌های پاپ‌آپ).
• **پراپ‌های اصلی:**
    • `visible`: یک مقدار `boolean` که نمایش یا عدم نمایش **Modal** را کنترل می‌کند.
    • `animationType`: نوع انیمیشن ورود (`'slide'`, `'fade'` یا `'none'`).
    • `onRequestClose`: برای پشتیبانی از دکمه بازگشت در اندروید ضروری است.

### ۴-۴: `StatusBar` - کنترل نوار وضعیت

• این کامپوننت به شما اجازه می‌دهد نوار وضعیت بالای صفحه (جایی که ساعت و باتری نمایش داده می‌شود) را کنترل کنید.
• **پراپ‌های اصلی:**
    • `barStyle`: رنگ متن و آیکون‌ها (`'default'`, `'light-content'`, `'dark-content'`).
    • `backgroundColor`: رنگ پس‌زمینه نوار (فقط اندروید).
    • `hidden`: برای مخفی کردن نوار وضعیت.

### ۴-۵: `Switch` - کلید دو حالته

• این کامپوننت یک کلید روشن/خاموش استاندارد نیتیو را نمایش می‌دهد.
• **پراپ‌های اصلی:**
    • `value`: یک مقدار `boolean` که وضعیت کلید را مشخص می‌کند.
    • `onValueChange`: تابعی که با تغییر وضعیت کلید توسط کاربر فراخوانی می‌شود.

### ۴-۶: `Alert` API

• `Alert` یک کامپوننت نیست، بلکه یک **API** است که یک دیالوگ هشدار استاندارد سیستم‌عامل را نمایش می‌دهد.
• شما تابع `Alert.alert(title, message, buttons)` را فراخوانی می‌کنید.
• این یک راه ساده برای نمایش پیام‌های مهم یا درخواست تأیید از کاربر است.
• **مثال:**
```javascript
import { Alert, Button } from 'react-native';

<Button
  title="نمایش هشدار"
  onPress={() =>
    Alert.alert(
      'عنوان هشدار',
      'این یک پیام هشدار است!',
      [
        {
          text: 'لغو',
          onPress: () => console.log('لغو شد'),
          style: 'cancel',
        },
        {
          text: 'تایید',
          onPress: () => console.log('تایید شد'),
        },
      ]
    )
  }
/>
```

***

## فصل ۵: هنر چیدمان و استایل‌دهی

در این فصل، تکنیک‌های پیشرفته‌تری برای ساخت **UI**های زیبا و واکنش‌گرا در **React Native** را یاد می‌گیریم.

### ۵-۱: موقعیت‌یابی مطلق (Absolute Positioning)

• به طور پیش‌فرض، تمام کامپوننت‌ها `position: 'relative'` دارند.
• اما گاهی شما می‌خواهید یک عنصر را **روی** عناصر دیگر قرار دهید (مثلاً یک نشان تعداد اعلان روی یک آیکون).
• در این مواقع از `position: 'absolute'` استفاده می‌کنیم.
• عنصری که این استایل را دارد، نسبت به نزدیک‌ترین والد خود که `position` آن `relative` است، موقعیت‌یابی می‌شود.

### ۵-۲: استایل‌دهی ریسپانسیو

ساخت **UI** که روی اندازه‌های مختلف صفحه خوب به نظر برسد، ترکیبی از چند تکنیک است:

1.  **Flexbox:**
    • بهترین ابزار شما برای چیدمان است.
    • با استفاده از `flex: 1` به کامپوننت‌ها اجازه می‌دهید فضای موجود را پر کنند.
    • با `justifyContent` و `alignItems` نیز می‌توانید توزیع فضا را مدیریت کنید.

2.  **درصد (%):**
    • می‌توانید برای `width` و `height` از مقادیر درصدی استفاده کنید.
    • این کار باعث می‌شود اندازه یک عنصر همیشه نسبتی از اندازه والدش باشد.

3.  **`useWindowDimensions`:**
    • این هوک ابعاد صفحه (عرض و ارتفاع) را به شما می‌دهد.
    • می‌توانید از آن برای تصمیم‌گیری‌های بزرگ در چیدمان استفاده کنید (مثلاً اگر عرض صفحه از یک مقداری بیشتر بود، لیست را دو ستونه نمایش بده).
    • **مثال:**
    ```javascript
    import { useWindowDimensions, View, Text } from 'react-native';

    function MyComponent() {
      const { width } = useWindowDimensions();
      return (
        <View style={{ flex: 1, backgroundColor: width > 500 ? 'lightblue' : 'lightgreen' }}>
          <Text>عرض صفحه: {width}</Text>
        </View>
      );
    }
    ```

### ۵-۳: کدنویسی مختص پلتفرم

گاهی لازم است ظاهر یا رفتار اپلیکیشن در iOS و Android متفاوت باشد. **React Native** چندین راه برای مدیریت این تفاوت‌ها ارائه می‌دهد:

• **ماژول `Platform`:**
    • این ماژول به شما اجازه می‌دهد در لحظه چک کنید که کد شما روی کدام سیستم‌عامل در حال اجراست.
    • `Platform.OS`: رشته `'ios'` یا `'android'` را برمی‌گرداند.
    • `Platform.select()`: تمیزترین راه برای تعریف استایل‌های متفاوت است.
    • **مثال:**
    ```javascript
    import { StyleSheet, Platform } from 'react-native';

    const styles = StyleSheet.create({
      card: {
        ...Platform.select({
          ios: { shadowColor: '#000', shadowOpacity: 0.1, shadowRadius: 5, shadowOffset: { width: 0, height: 2 } },
          android: { elevation: 3 },
        }),
        backgroundColor: 'white',
        padding: 20,
        margin: 10,
        borderRadius: 8,
      },
    });
    ```

• **پسوندهای فایل:**
    • برای تفاوت‌های بزرگ‌تر در منطق یا کامپوننت‌ها، می‌توانید دو فایل جداگانه بسازید.
    • مانند `Component.ios.js` و `Component.android.js`.
    • باندلر (**Metro**) به صورت هوشمند فایل صحیح را بر اساس پلتفرم هدف انتخاب می‌کند.
    • این روش برای جداسازی کامل کد مختص هر پلتفرم بسیار مفید است.

***

## فصل ۶: نمایش لیست‌های بهینه

نمایش لیست‌های داده یکی از رایج‌ترین و مهم‌ترین کارها در اپلیکیشن‌های موبایل است. در این فصل، با کامپوننت‌های مختلف برای نمایش لیست‌ها و نحوه بهینه‌سازی آن‌ها آشنا می‌شویم.

### ۶-۱: `ScrollView`

• یک کانتینر اسکرول ساده است.
• **نقطه ضعف بزرگ:** `ScrollView` تمام کامپوننت‌های فرزند خود را **یکجا رندر می‌کند**.
• این باعث می‌شود برای لیست‌های بلند، مصرف حافظه بالا رفته و اپلیکیشن کند شود.
• **کاربرد:** برای صفحاتی با تعداد محدودی آیتم یا محتوای متنی بلند مناسب است. برای مثال، یک صفحه تنظیمات یا یک مقاله.

### ۶-۲: `FlatList` (انتخاب استاندارد)

• کامپوننت اصلی و بهینه برای نمایش لیست‌های بلند است.
• **قابلیت کلیدی: مجازی‌سازی (Virtualization).**
    • `FlatList` هوشمند است و فقط آیتم‌هایی را که روی صفحه قابل مشاهده هستند رندر می‌کند.
    • این کار عملکرد را فوق‌العاده بالا می‌برد و مصرف حافظه را کاهش می‌دهد.
• **پراپ‌های ضروری:**
    • `data`: آرایه‌ای از داده‌ها که قرار است نمایش داده شوند.
    • `renderItem`: تابعی که یک آیتم از داده را گرفته و کامپوننت مربوط به آن را برمی‌گرداند.
    • `keyExtractor`: تابعی که یک کلید (**key**) منحصر به فرد و از نوع **رشته** برای هر آیتم برمی‌گرداند. این برای عملکرد **React** و `FlatList` بسیار مهم است.
• **مثال:**
```javascript
import React from 'react';
import { FlatList, Text, View, StyleSheet } from 'react-native';

const DATA = [
  { id: '1', title: 'آیتم اول' },
  { id: '2', title: 'آیتم دوم' },
  { id: '3', title: 'آیتم سوم' },
];

const Item = ({ title }) => (
  <View style={styles.item}>
    <Text style={styles.title}>{title}</Text>
  </View>
);

export default function MyFlatList() {
  return (
    <FlatList
      data={DATA}
      renderItem={({ item }) => <Item title={item.title} />}
      keyExtractor={item => item.id}
    />
  );
}

const styles = StyleSheet.create({
  item: {
    backgroundColor: '#f9c2ff',
    padding: 20,
    marginVertical: 8,
    marginHorizontal: 16,
  },
  title: {
    fontSize: 20,
  },
});
```

### ۶-۳: `SectionList`

• این کامپوننت برای داده‌هایی است که به صورت **بخش‌بندی شده** هستند (مانند لیست مخاطبین که بر اساس حروف الفبا گروه‌بندی شده‌اند).
• **پراپ‌های اصلی:**
    • `sections`: آرایه‌ای از آبجکت‌ها که هر آبجکت شامل `title` و آرایه `data` برای آن بخش است.
    • `renderItem`: برای رندر هر آیتم در یک بخش.
    • `renderSectionHeader`: برای رندر کردن هدر هر بخش.

***

## فصل ۷: هویت بصری: فونت و صفحه اسپلش

در این فصل، دو ابزار مهم برای کنترل ظاهر و تجربه اولیه اپلیکیشن، یعنی فونت‌های سفارشی و مدیریت صفحه اسپلش، را یاد می‌گیریم.

### ۷-۱: کار با فونت‌های سفارشی (`useFonts`)

برای استفاده از فونت‌های اختصاصی در پروژه، از هوک `useFonts` از کتابخانه `expo-font` استفاده می‌کنیم. این هوک به ما اجازه می‌دهد فونت‌ها را قبل از استفاده، بارگذاری کنیم تا از پرش متن (**FOUT** - Flash of Unstyled Text) جلوگیری شود.

• **فرآیند:**
1.  فایل‌های فونت (`.ttf` یا `.otf`) را در پوشه `assets/fonts` پروژه خود قرار دهید.
2.  با استفاده از `useFonts` در کامپوننت اصلی (معمولاً `app/_layout.tsx` یا `App.js` شما)، فونت‌ها را بارگذاری کنید.
3.  تا زمانی که فونت‌ها به طور کامل بارگذاری نشده‌اند، رندر اپلیکیشن را متوقف کنید (با برگرداندن `null` از کامپوننت اصلی). این تضمین می‌کند که UI با فونت‌های صحیح نمایش داده شود.
4.  پس از بارگذاری موفقیت‌آمیز، نام تعریف شده برای فونت را در پراپ `fontFamily` در استایل‌های خود استفاده کنید.
• **نکته:** بارگذاری فونت به تنهایی آن را به کل برنامه اعمال **نمی‌کند**. شما باید به صراحت در استایل‌های `Text` خود از آن استفاده کنید.
• **مثال (در `app/_layout.tsx` یا `App.js`):**
```javascript
import { useFonts } from 'expo-font';
import * as SplashScreen from 'expo-splash-screen';
import { useEffect } from 'react';

// جلوگیری از مخفی شدن خودکار صفحه اسپلش تا زمانی که فونت‌ها بارگذاری شوند
SplashScreen.preventAutoHideAsync(); //

export default function RootLayout() {
  const [fontsLoaded] = useFonts({
    'OpenSans-Regular': require('./assets/fonts/OpenSans-Regular.ttf'),
    'OpenSans-Bold': require('./assets/fonts/OpenSans-Bold.ttf'),
  }); //

  useEffect(() => {
    if (fontsLoaded) {
      SplashScreen.hideAsync(); // مخفی کردن صفحه اسپلش پس از بارگذاری فونت‌ها
    }
  }, [fontsLoaded]);

  if (!fontsLoaded) {
    return null; // نمایش ندادن هیچ چیزی تا فونت‌ها بارگذاری شوند
  }

  return (
    // ... محتوای اصلی اپلیکیشن شما
    // در اینجا می‌توانید از فونت‌ها استفاده کنید:
    // <Text style={{ fontFamily: 'OpenSans-Bold', fontSize: 24 }}>متن با فونت سفارشی</Text>
  );
}
```

### ۷-۲: مدیریت صفحه اسپلش (`expo-splash-screen`)

صفحه اسپلش اولین چیزی است که کاربر می‌بیند، حتی قبل از اینکه جاوااسکریپت برنامه شما اجرا شود. ما می‌توانیم با این ماژول، نمایش این صفحه را کنترل کنیم تا تمام فرآیندهای آماده‌سازی (مانند بارگذاری فونت یا دریافت تنظیمات اولیه) به طور کامل انجام شوند.

• **گردش کار:**
1.  در ابتدای برنامه (معمولاً در فایل اصلی مانند `app/_layout.tsx` یا `App.js`) با فراخوانی `SplashScreen.preventAutoHideAsync()` از بسته شدن خودکار صفحه اسپلش جلوگیری می‌کنیم.
2.  پس از اینکه تمام کارهای لازم برای آماده‌سازی اپلیکیشن انجام شد (مثلاً فونت‌ها بارگذاری شدند، داده‌های اولیه فچ شدند)، تابع `SplashScreen.hideAsync()` را فراخوانی می‌کنیم تا صفحه اسپلش به نرمی محو شود و رابط کاربری اصلی شما نمایش داده شود.

***

## فصل ۸: ناوبری مدرن با Expo Router

• **Expo Router** یک لایه هوشمند روی کتابخانه قدرتمند **React Navigation** است.
• این به ما اجازه می‌دهد ناوبری را به صورت فایل‌محور و شبیه به **Next.js** انجام دهیم. این رویکرد کدنویسی ناوبری را بسیار تمیزتر و قابل پیش‌بینی‌تر می‌کند.

### ۸-۱: مفاهیم کلیدی

• **مسیریابی مبتنی بر فایل:**
    • هر فایل در پوشه `app` به یک مسیر در اپلیکیشن تبدیل می‌شود.
    • برای مثال، فایل `app/settings.tsx` به مسیر `/settings` در اپلیکیشن شما تبدیل می‌شود.

• **چیدمان‌ها (`_layout.tsx`):**
    • این فایل نوع ناوبر (**Navigator**) را برای یک پوشه و تمام زیرشاخه‌هایش مشخص می‌کند.
    • فایل `app/_layout.tsx` ناوبر اصلی کل برنامه (معمولاً یک `Stack` Navigator) را تعریف می‌کند. این به شما اجازه می‌دهد سربرگ‌ها، برگه‌ها، و سایر عناصر ناوبری را به صورت سراسری مدیریت کنید.

• **گروه‌بندی مسیرها:**
    • پوشه‌هایی که نامشان داخل پرانتز است (مانند `(tabs)`)، در **URL** تأثیری ندارند.
    • این پوشه‌ها فقط برای سازماندهی و اعمال یک چیدمان خاص به گروهی از صفحات استفاده می‌شوند. مثلاً می‌توانید تمام تب‌های اپلیکیشن را در پوشه `(tabs)` قرار دهید و یک **Tab Navigator** برای آن‌ها تعریف کنید.

### ۸-۲: ابزارهای ناوبری

**Expo Router** مجموعه‌ای از هوک‌ها و کامپوننت‌ها را برای مدیریت ناوبری ارائه می‌دهد:

• **کامپوننت `Link`:**
    • برای ناوبری **اعلانی (Declarative)** استفاده می‌شود، یعنی ناوبری که توسط کاربر از طریق کلیک روی یک عنصر اتفاق می‌افتد.
    • `href`: مسیر مقصد را مشخص می‌کند. می‌تواند یک رشته ساده باشد (مانند `href="/settings"`) یا یک آبجکت برای ارسال پارامترها.
    • `replace`: اگر `true` باشد، صفحه فعلی را جایگزین می‌کند و از تاریخچه ناوبری حذف می‌کند. (عالی برای سناریوهایی مانند هدایت کاربر به داشبورد پس از ورود موفقیت‌آمیز، که نمی‌خواهید کاربر به صفحه ورود بازگردد).
    • `asChild`: این پراپ به `Link` می‌گوید که خودش هیچ **UI** رندر نکند و فقط قابلیت ناوبری را به اولین فرزند خود (مثلاً یک `Pressable` یا یک دکمه سفارشی) منتقل کند. این به شما اجازه می‌دهد دکمه‌های کاملاً سفارشی بسازید که مانند یک لینک عمل می‌کنند.
    • **ارسال پارامتر با `href`:** شما می‌توانید به جای یک رشته، یک آبجکت به پراپ `href` پاس دهید.
    ```javascript
    import { Link } from 'expo-router';
    // ...
    <Link href="/settings">
      <Text>رفتن به تنظیمات</Text>
    </Link>

    // استفاده از replace
    <Link href="/dashboard" replace>
      <Text>ورود به داشبورد</Text>
    </Link> //

    // با asChild برای یک دکمه سفارشی
    <Link href="/profile" asChild>
      <Pressable>
        <Text>مشاهده پروفایل</Text>
      </Pressable>
    </Link> //

    // ارسال پارامترها
    <Link href={{ pathname: '/user/[id]', params: { id: '123' } }}>
      <Text>مشاهده کاربر</Text>
    </Link> //
    ```

• **هوک `useRouter`:**
    • برای ناوبری **دستوری (Imperative)** استفاده می‌شود، یعنی ناوبری که از داخل کد (مانند بعد از ارسال فرم یا یک عملیات **API**) اتفاق می‌افتد.
    • `router.push('/path')`: یک صفحه جدید را روی پشته (**stack**) قرار می‌دهد. کاربر می‌تواند با دکمه بازگشت به صفحه قبلی بازگردد.
    • `router.replace('/path')`: صفحه فعلی را با یک صفحه جدید **جایگزین** می‌کند. کاربر نمی‌تواند به صفحه قبلی بازگردد. (عالی برای سناریوهایی مانند بعد از لاگین کردن یا تکمیل یک فرآیند).
    • `router.back()`: به صفحه قبلی در پشته بازمی‌گردد.

• **هوک `useLocalSearchParams`:**
    • برای خواندن پارامترهای داینامیک از **URL** **صفحه فعلی** استفاده می‌شود.
    • **کاربرد:** اگر شما یک مسیر داینامیک مانند `app/user/[id].tsx` داشته باشید و کاربر به آدرس `/user/123` برود، این هوک آبجکتی به شکل `{ id: '123' }` را برمی‌گرداند.
    • **مثال (در فایل `app/user/[id].tsx`):**
    ```javascript
    import { useLocalSearchParams } from 'expo-router';
    import { Text } from 'react-native';

    export default function UserProfile() {
      const { id } = useLocalSearchParams<{ id: string }>(); //
      return <Text>پروفایل کاربر با شناسه: {id}</Text>; //
    }
    ```

• **هوک `usePathname`:**
    • این یک هوک ساده است که آدرس مسیر فعلی را به صورت یک رشته برمی‌گرداند (مثلاً `/user/123`).
    • **کاربرد:** برای هایلایت کردن لینک فعال در یک منوی سفارشی یا ارسال آدرس فعلی به سرویس‌های آنالیتیکس.

***

## فصل ۹: ارتباط با دنیای خارج: شبکه (Networking)

• اپلیکیشن‌ها برای دریافت و ارسال داده به سرورها و ارتباط با خدمات ابری، از اینترنت استفاده می‌کنند.
• این فصل شما را با روش‌های مختلف برقراری ارتباط شبکه‌ای در **React Native** آشنا می‌کند.

### ۹-۱: `Fetch API`

• **React Native** به صورت داخلی از **Fetch API** پشتیبانی می‌کند.
• **Fetch API** یک استاندارد مدرن وب برای ارسال درخواست‌های شبکه است.
• این **API** مبتنی بر **Promise** است و به خوبی با `async/await` کار می‌کند.
• **مثال:**
```javascript
const fetchData = async () => {
  try {
    const response = await fetch('https://api.example.com/data');
    const json = await response.json();
    console.log(json);
  } catch (error) {
    console.error('خطا در دریافت داده:', error);
  }
};
```

### ۹-۲: گردش کار دریافت داده (الگوی کلاسیک)

این الگو از هوک‌های `useEffect` و `useState` برای مدیریت چرخه حیات داده در کامپوننت‌های تابعی استفاده می‌کند:

1.  **تعریف State ها:**
    • سه **state** برای نگهداری `data` (داده‌های موفق), `isLoading` (وضعیت لودینگ) و `error` (خطای احتمالی) تعریف می‌کنیم.
    • مثال: `const [data, setData] = useState(null);` `const [isLoading, setIsLoading] = useState(true);` `const [error, setError] = useState(null);`.

2.  **ارسال درخواست:**
    • درخواست `fetch` را داخل یک `useEffect` با آرایه وابستگی خالی (`[]`) قرار می‌دهیم.
    • این تضمین می‌کند که درخواست فقط یک بار هنگام باز شدن صفحه یا کامپوننت اجرا شود.

3.  **مدیریت پاسخ:**
    • از یک بلاک `try...catch...finally` استفاده می‌کنیم.
    • در `try`، داده‌های دریافت شده را در `state` `data` قرار می‌دهیم.
    • در `catch`، هر گونه خطا را ذخیره می‌کنیم.
    • در `finally`، وضعیت `isLoading` را به `false` تغییر می‌دهیم تا نشان دهیم عملیات شبکه به پایان رسیده است.

4.  **رندر شرطی:**
    • در **UI**، بر اساس مقادیر `isLoading` و `error`، یک نمایشگر لودینگ، پیام خطا یا لیست داده‌ها را نمایش می‌دهیم.

• **مثال:**
```javascript
import React, { useState, useEffect } from 'react';
import { View, Text, ActivityIndicator, StyleSheet } from 'react-native';

export default function DataFetcherClassic() {
  const [data, setData] = useState(null); //
  const [isLoading, setIsLoading] = useState(true); //
  const [error, setError] = useState(null); //

  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await fetch('https://jsonplaceholder.typicode.com/todos/1');
        if (!response.ok) {
          throw new Error('خطا در شبکه');
        }
        const json = await response.json();
        setData(json); //
      } catch (err) {
        setError(err.message); //
      } finally {
        setIsLoading(false); //
      }
    };
    fetchData();
  }, []); //

  if (isLoading) {
    return <ActivityIndicator size="large" color="#0000ff" />; //
  }

  if (error) {
    return <Text style={styles.errorText}>خطا: {error}</Text>; //
  }

  return (
    <View style={styles.container}>
      <Text style={styles.title}>داده دریافت شده:</Text>
      <Text>شناسه کاربر: {data.userId}</Text>
      <Text>شناسه: {data.id}</Text>
      <Text>عنوان: {data.title}</Text>
      <Text>تکمیل شده: {data.completed ? 'بله' : 'خیر'}</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, justifyContent: 'center', alignItems: 'center', padding: 20 },
  title: { fontSize: 20, fontWeight: 'bold', marginBottom: 10 },
  errorText: { color: 'red', fontSize: 18 },
});
```

### ۹-۳: گردش کار مدرن با React 19 (`use` و `Suspense`)

• با پشتیبانی **Expo** از **React 19** (یا نسخه‌های بالاتر که این ویژگی‌ها را دارند)، می‌توانیم فرآیند دریافت داده را بسیار ساده‌تر کنیم.
• این الگو نیاز به مدیریت **state**های لودینگ و خطا را در هر کامپوننت از بین می‌برد.

• **هوک `use`:**
    • این هوک به ما اجازه می‌دهد نتیجه یک **Promise** را مستقیماً "باز" کنیم.
    • دیگر نیازی به `useEffect` و `useState` برای مدیریت چرخه حیات درخواست نیست.
    • این هوک فقط در کامپوننت‌های سمت سرور (**Server Components**) یا کامپوننت‌هایی که با **Suspense** پیچیده شده‌اند قابل استفاده است.

• **`Suspense`:**
    • این کامپوننت به ما اجازه می‌دهد تا یک **UI** جایگزین (**fallback**) (مانند `ActivityIndicator` یا یک **skeleton UI**) را نمایش دهیم.
    • این **fallback UI** تا زمانی که داده‌های کامپوننت فرزند آماده شوند، به کاربر نمایش داده می‌شود.
    • این یک راه بسیار تمیز برای مدیریت وضعیت‌های لودینگ در سطح کامپوننت است.

• **مثال:**
```javascript
// کامپوننت والد (ParentComponent)
import { Suspense, ActivityIndicator, View } from 'react'; //
import { Text } from 'react-native'; //

function ParentComponent() {
  return (
    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
      <Suspense fallback={<ActivityIndicator size="large" color="#0000ff" />}> {/* */}
        <MyDataComponent /> {/* */}
      </Suspense>
    </View>
  );
}

// کامپوننت فرزند (MyDataComponent)
import { use } from 'react'; //

const fetchMyData = () =>
  fetch('https://jsonplaceholder.typicode.com/todos/1').then(res => res.json()); //

function MyDataComponent() {
  // دیگر نیازی به بررسی isLoding و error نیست، Suspense آن را مدیریت می‌کند
  const data = use(fetchMyData()); //

  return (
    <View>
      <Text style={{ fontSize: 20, fontWeight: 'bold' }}>داده دریافت شده:</Text>
      <Text>عنوان: {data.title}</Text>
      <Text>وضعیت: {data.completed ? 'تکمیل شده' : 'در حال انجام'}</Text>
    </View>
  );
}

export default ParentComponent;
```

***

## فصل ۱۰: حافظه پایدار: ذخیره‌سازی داده‌ها

اغلب نیاز داریم اطلاعات را روی دستگاه کاربر ذخیره کنیم تا با بسته و باز شدن اپلیکیشن، این اطلاعات از بین نروند. این فصل به شما ابزارهای اصلی برای ذخیره‌سازی داده‌ها در **React Native** را معرفی می‌کند.

### ۱۰-۱: AsyncStorage - انبار ساده کلید-مقدار

• این کتابخانه، استاندارد اصلی برای ذخیره داده‌های **ساده و غیرحساس** است.
• عملکردی شبیه `localStorage` در وب دارد.
• **ساختار:** کلید-مقدار (**Key-Value**). هر دو کلید و مقدار باید به صورت **رشته (string)** ذخیره شوند.
• برای ذخیره آبجکت‌ها یا آرایه‌ها، باید ابتدا آن‌ها را با `JSON.stringify()` به رشته تبدیل کرده و هنگام خواندن با `JSON.parse()` دوباره به آبجکت تبدیل کنید.
• **کاربرد:** ذخیره تنظیمات کاربر (مانند تم برنامه، زبان)، نام کاربری، یا وضعیت‌های کوچک.
• **نصب:** `npx expo install @react-native-async-storage/async-storage`
• **مثال:**
```javascript
import AsyncStorage from '@react-native-async-storage/async-storage';

const saveItem = async (key, value) => {
  try {
    await AsyncStorage.setItem(key, value);
    console.log('داده ذخیره شد!');
  } catch (e) {
    console.error('خطا در ذخیره داده:', e);
  }
};

const getItem = async (key) => {
  try {
    const value = await AsyncStorage.getItem(key);
    if (value !== null) {
      console.log('داده خوانده شد:', value);
      return value;
    }
  } catch (e) {
    console.error('خطا در خواندن داده:', e);
  }
  return null;
};

// ذخیره یک آبجکت
const saveObject = async (key, obj) => {
  try {
    const jsonValue = JSON.stringify(obj);
    await AsyncStorage.setItem(key, jsonValue);
  } catch (e) {
    console.error('خطا در ذخیره آبجکت:', e);
  }
};

// خواندن یک آبجکت
const getObject = async (key) => {
  try {
    const jsonValue = await AsyncStorage.getItem(key);
    return jsonValue != null ? JSON.parse(jsonValue) : null;
  } catch (e) {
    console.error('خطا در خواندن آبجکت:', e);
  }
};
```

### ۱۰-۲: SecureStore - گاوصندوق اطلاعات حساس

• برای ذخیره اطلاعات حساس که نباید به راحتی قابل خواندن باشند، از `expo-secure-store` استفاده می‌کنیم.
• **امنیت:** این ماژول از قابلیت‌های امنیتی خود سیستم‌عامل (**Keychain** در iOS و **Keystore** در Android) برای رمزنگاری داده‌ها استفاده می‌کند. این داده‌ها به صورت امن ذخیره می‌شوند و دسترسی به آن‌ها محدود است.
• **کاربرد:** ذخیره توکن‌های احراز هویت (**JWT**), کلیدهای **API** خصوصی، و رمزهای عبور.
• **نصب:** `npx expo install expo-secure-store`
• **مثال:**
```javascript
import * as SecureStore from 'expo-secure-store';

const saveSecureValue = async (key, value) => {
  try {
    await SecureStore.setItemAsync(key, value);
    console.log('مقدار امن ذخیره شد!');
  } catch (e) {
    console.error('خطا در ذخیره مقدار امن:', e);
  }
};

const getSecureValue = async (key) => {
  try {
    const value = await SecureStore.getItemAsync(key);
    if (value) {
      console.log('مقدار امن خوانده شد:', value);
      return value;
    }
  } catch (e) {
    console.error('خطا در خواندن مقدار امن:', e);
  }
  return null;
};
```

### ۱۰-۳: SQLite - دیتابیس رابطه‌ای

• برای داده‌های **حجیم، پیچیده و رابطه‌ای**، به یک دیتابیس واقعی روی دستگاه نیاز داریم.
• `expo-sqlite` یک پیاده‌سازی از دیتابیس محبوب **SQLite** را فراهم می‌کند.
• **کاربرد:** ساخت اپلیکیشن‌هایی که باید به صورت آفلاین به خوبی کار کنند، اپ‌های مدیریت وظایف، یا هر برنامه‌ای با داده‌های ساختاریافته که نیاز به جستجو و فیلترهای پیچیده دارند.
• **نصب:** `npx expo install expo-sqlite`
• **مثال (ایجاد دیتابیس و جدول):**
```javascript
import * as SQLite from 'expo-sqlite';

const db = SQLite.openDatabase('myDatabase.db');

const initDatabase = () => {
  db.transaction(tx => {
    tx.executeSql(
      'CREATE TABLE IF NOT EXISTS items (id INTEGER PRIMARY KEY NOT NULL, name TEXT NOT NULL);',
      [],
      () => console.log('جدول ساخته شد یا از قبل وجود داشت.'),
      (_, error) => console.error('خطا در ساخت جدول:', error)
    );
  });
};

// فراخوانی در ابتدای برنامه
// initDatabase();
```

***

## فصل ۱۱: روح بخشیدن به اپ: انیمیشن و جسچرها

انیمیشن‌های روان و بازخوردهای لمسی، تجربه کاربری را به سطح دیگری می‌برند و اپلیکیشن شما را زنده و جذاب می‌کنند.

### ۱۱-۱: انیمیشن با React Native Reanimated

• `Reanimated` کتابخانه استاندارد و مدرن برای انیمیشن است.
• دلیل اصلی محبوبیت آن این است که منطق انیمیشن را مستقیماً روی **نخ UI** اجرا می‌کند که باعث عملکردی روان و ۶۰ فریم بر ثانیه می‌شود. این از گیر کردن انیمیشن‌ها هنگام پردازش‌های سنگین در نخ **JS** جلوگیری می‌کند.

• **مفاهیم اصلی:**
    • **`useSharedValue`**: مانند `useState` است، اما برای مقادیری که قرار است انیمیت شوند. تغییر این مقادیر مستقیماً در نخ **UI** اعمال می‌شود.
    • **`useAnimatedStyle`**: استایل‌ها را به مقادیر اشتراکی (`useSharedValue`) متصل می‌کند. این هوک یک آبجکت استایل برمی‌گرداند که می‌توانید آن را به کامپوننت‌های **Animated** خود بدهید.
    • **`Animated.View`**: نسخه‌ای از کامپوننت `View` (و سایر کامپوننت‌ها مانند `Animated.Text` یا `Animated.Image`) که می‌تواند استایل‌های انیمیشنی را دریافت کند.
    • **`withTiming` و `withSpring`**: توابعی که به **Reanimated** می‌گویند یک مقدار را **چگونه** (مثلاً با زمان‌بندی مشخص یا به صورت فنری) انیمیت کند.
        • `withTiming`: برای انیمیشن‌های با مدت زمان مشخص و منحنی (easing).
        • `withSpring`: برای انیمیشن‌های فنری و طبیعی‌تر.

• **مثال (یک `View` که با کلیک کردن اندازه آن تغییر می‌کند):**
```javascript
import React from 'react';
import { Button, StyleSheet } from 'react-native';
import Animated, { useSharedValue, useAnimatedStyle, withTiming } from 'react-native-reanimated';

export default function ReanimatedExample() {
  const width = useSharedValue(100); //

  const animatedStyle = useAnimatedStyle(() => {
    return {
      width: withTiming(width.value, { duration: 500 }), //
    };
  }); //

  const handlePress = () => {
    width.value = width.value === 100 ? 200 : 100; // تغییر مقدار اشتراکی
  };

  return (
    <Animated.View style={[styles.box, animatedStyle]} />
    <Button onPress={handlePress} title="تغییر اندازه" />
  );
}

const styles = StyleSheet.create({
  box: {
    height: 100,
    backgroundColor: 'red',
    margin: 50,
  },
});
```

### ۱۱-۲: کار با حرکات لمسی (Gestures)

• برای مدیریت حرکات لمسی پیچیده مانند کشیدن (**Drag**), زوم کردن، یا چرخاندن، ما از کتابخانه **`react-native-gesture-handler`** در ترکیب با **Reanimated** استفاده می‌کنیم.
• این ترکیب به شما امکان می‌دهد جسچرهای پیچیده را تعریف کنید و انیمیشن‌های مربوطه را مستقیماً روی نخ **UI** اجرا کنید.

• **API مدرن:**
    • به جای هوک‌های قدیمی، از آبجکت **`Gesture`** برای تعریف نوع حرکت (مثلاً `Gesture.Pan()` برای کشیدن) استفاده می‌کنیم.
    • و از کامپوننت **``** برای اعمال آن به یک عنصر استفاده می‌کنیم.
    • این باعث می‌شود تعریف جسچرها بسیار تمیزتر و ماژولارتر باشد.

• **Worklets:**
    • توابعی که قرار است در پاسخ به جسچرها روی نخ **UI** اجرا شوند، باید با دستورالعمل `"worklet";` در ابتدای آن‌ها مشخص شوند.
    • این دستورالعمل به باندلر می‌گوید که این تابع را برای اجرا در محیط **Reanimated** آماده کند و از کرش کردن برنامه جلوگیری می‌کند.

• **مثال (کشیدن یک جعبه):**
```javascript
import React from 'react';
import { StyleSheet, View } from 'react-native';
import { GestureDetector, Gesture } from 'react-native-gesture-handler'; //
import Animated, { useAnimatedStyle, useSharedValue } from 'react-native-reanimated'; //

export default function DraggableBox() {
  const translateX = useSharedValue(0); //
  const translateY = useSharedValue(0); //

  const panGesture = Gesture.Pan()
    .onUpdate((event) => {
      'worklet'; //
      translateX.value = event.translationX;
      translateY.value = event.translationY;
    })
    .onEnd(() => {
      'worklet'; //
      // می‌توانید اینجا جعبه را به موقعیت اولیه برگردانید یا آن را در جای جدید رها کنید
    });

  const animatedStyle = useAnimatedStyle(() => {
    return {
      transform: [
        { translateX: translateX.value },
        { translateY: translateY.value },
      ],
    };
  }); //

  return (
    <GestureDetector gesture={panGesture}> {/* */}
      <Animated.View style={[styles.box, animatedStyle]} />
    </GestureDetector>
  );
}

const styles = StyleSheet.create({
  box: {
    width: 100,
    height: 100,
    backgroundColor: 'blue',
    borderRadius: 10,
  },
});
```

***

## فصل ۱۲: تضمین کیفیت: تست‌نویسی (Testing)

نوشتن تست‌های خودکار تضمین می‌کند که اپلیکیشن شما در طول زمان باکیفیت و پایدار باقی بماند. این فصل شما را با سه نوع اصلی تست‌نویسی در **React Native** آشنا می‌کند.

### ۱۲-۱: تست واحد (Unit Testing)

• **هدف:** تست کردن کوچکترین واحد کد (مانند یک تابع خالص یا یک ماژول کوچک) به صورت ایزوله.
• این تست‌ها اطمینان می‌دهند که هر بخش از کد به درستی کار می‌کند، مستقل از بقیه سیستم.
• **ابزار:** **Jest**. این فریم‌ورک به طور پیش‌فرض در پروژه‌های **Expo** پیکربندی شده است و یک ابزار قدرتمند برای تست جاوااسکریپت است.
• **مثال (تست یک تابع جمع):**
```javascript
// functions.js
export function sum(a, b) {
  return a + b;
}

// functions.test.js
import { sum } from './functions';

test('sum adds 1 + 2 to equal 3', () => {
  expect(sum(1, 2)).toBe(3);
});
```

### ۱۲-۲: تست کامپوننت (Component Testing)

• **هدف:** تست کردن یک کامپوننت **React** به تنهایی.
• بررسی می‌کند که آیا کامپوننت به درستی رندر می‌شود و به تعاملات کاربر (مانند کلیک کردن روی دکمه‌ها یا وارد کردن متن) واکنش صحیح نشان می‌دهد.
• این تست‌ها بر خروجی **UI** و رفتار کامپوننت تمرکز دارند، نه بر جزئیات پیاده‌سازی داخلی.
• **ابزار:** **React Native Testing Library**. این کتابخانه یک رویکرد کاربر-محور برای تست کامپوننت‌ها را ترویج می‌کند.
• **مثال (تست یک کامپوننت ساده دکمه):**
```javascript
// MyButton.js
import React from 'react';
import { Button } from 'react-native';

export default function MyButton({ onPress, title }) {
  return <Button title={title} onPress={onPress} />;
}

// MyButton.test.js
import React from 'react';
import { render, fireEvent } from '@testing-library/react-native';
import MyButton from './MyButton';

test('renders correctly and calls onPress', () => {
  const mockOnPress = jest.fn();
  const { getByText } = render(<MyButton title="کلیک کن" onPress={mockOnPress} />);

  const button = getByText('کلیک کن');
  fireEvent.press(button);

  expect(mockOnPress).toHaveBeenCalledTimes(1);
});
```

### ۱۲-۳: تست سرتاسری (End-to-End - E2E)

• **هدف:** تست کردن کل جریان کاری اپلیکیشن، از دید یک کاربر واقعی.
• یک ربات (یا ابزار خودکارسازی) اپلیکیشن را روی یک شبیه‌ساز یا دستگاه واقعی باز کرده و سناریوهای مختلف را اجرا می‌کند.
• این تست‌ها مطمئن می‌شوند که تمام بخش‌های اپلیکیشن (از **UI** تا بک‌اند) به درستی با هم کار می‌کنند.
• **ابزارها:** **Maestro** (که جدید و ساده‌تر است) یا **Detox** (یک ابزار قدرتمند و بالغ‌تر).
• این تست‌ها معمولاً پیچیده‌تر هستند اما بالاترین سطح اطمینان را ارائه می‌دهند.

***

## فصل ۱۳: بهینه‌سازی و عملکرد (Performance Optimization)

در این فصل، یاد می‌گیریم چطور اپلیکیشن خود را سریع، روان و بهینه نگه داریم تا بهترین تجربه کاربری را ارائه دهیم.

### ۱۳-۱: ابزارهای اصلی

• **Profiler:**
    • در **React DevTools** (که از طریق **Flipper** قابل دسترسی است)، تب **Profiler** به شما اجازه می‌دهد عملکرد رندرینگ اپلیکیشن را ضبط کنید.
    • این به شما کمک می‌کند تا ببینید کدام کامپوننت‌ها بیهوده دوباره رندر می‌شوند یا رندر آن‌ها زمان‌بر است.

• **Flipper:**
    • یک اپلیکیشن دسکتاپ و ابزار دیباگینگ همه‌کاره است.
    • پلاگین‌هایی برای بررسی چیدمان (**Layout**), شبکه (**Network**), لاگ‌ها و... ارائه می‌دهد.
    • **Flipper** به شما دید عمیقی از آنچه در اپلیکیشن شما اتفاق می‌افتد می‌دهد و برای بهینه‌سازی بسیار مفید است.

### ۱۳-۲: تکنیک‌های بهینه‌سازی

• **جلوگیری از رندرهای غیرضروری:**
    • **`React.memo`**: یک **Higher-Order Component (HOC)** است که کامپوننت‌های تابعی را **memoize** می‌کند. این کامپوننت‌ها اگر **props** آن‌ها تغییر نکرده باشد، از رندر شدن مجدد محافظت می‌شوند.
    • **`useCallback`**: از ساخته شدن مجدد توابع در هر رندر جلوگیری می‌کند. این هوک به خصوص برای توابعی که به عنوان **props** به کامپوننت‌های `memoized` پاس داده می‌شوند، مفید است تا رندر غیرضروری آن‌ها را متوقف کند.
    • **`useMemo`**: نتیجه محاسبات سنگین را در حافظه **کش** می‌کند تا از اجرای مجدد آن‌ها در هر رندر جلوگیری شود. از این هوک برای محاسباتی استفاده کنید که زمان‌بر هستند.

• **بهینه‌سازی `FlatList`:**
    • `FlatList` به طور طبیعی بهینه است، اما پراپ‌های خاصی می‌توانند عملکرد آن را برای لیست‌های بسیار بلند بیشتر بهبود بخشند.
    • `getItemLayout`: اگر ارتفاع آیتم‌ها ثابت است، با تعریف این پراپ می‌توانید به `FlatList` کمک کنید تا بدون نیاز به اندازه‌گیری، موقعیت و ابعاد آیتم‌ها را محاسبه کند. این به اسکرولینگ بسیار روان‌تر منجر می‌شود.
    • `initialNumToRender`: تعداد آیتم‌هایی که `FlatList` باید در ابتدا رندر کند را مشخص می‌کند. تنظیم صحیح این مقدار می‌تواند زمان بارگذاری اولیه را بهبود بخشد.

• **موتور Hermes:**
    • **Hermes** موتور جاوااسکریپت بهینه‌سازی شده برای **React Native** است که توسط **Meta** توسعه یافته است.
    • این موتور به طور پیش‌فرض در پروژه‌های **Expo** فعال است و باعث کاهش مصرف حافظه و افزایش سرعت بارگذاری اولیه اپلیکیشن می‌شود.
    • فعال بودن **Hermes** به طور کلی عملکرد اپلیکیشن شما را به میزان قابل توجهی بهبود می‌بخشد.

***

## فصل ۱۴: گردش کار حرفه‌ای: Development Builds

• این بخش، کلید عبور از محدودیت‌های گذشته **Expo Go** و رسیدن به نهایت قدرت **Expo** است.

### ۱۴-۱: مشکل Expo Go

• اپلیکیشن **Expo Go** فقط شامل مجموعه‌ای از ماژول‌های نیتیو از پیش نصب شده است.
• اگر شما به یک کتابخانه نیتیو دیگر نیاز داشته باشید که در **Expo Go** موجود نیست (مانند **react-native-blur** یا یک ماژول سفارشی)، اپلیکیشن شما در **Expo Go** کرش می‌کند و قابل اجرا نخواهد بود.

### ۱۴-۲: راه حل: Development Builds

• **Development Build** یک نسخه کاملاً **سفارشی از اپلیکیشن Expo Go** است که **مخصوص پروژه شما** ساخته می‌شود.
• این بیلد، علاوه بر ماژول‌های پیش‌فرض **Expo**، **تمام کتابخانه‌های نیتیو دیگری که شما به پروژه خود اضافه کرده‌اید** را نیز شامل می‌شود.
• **نتیجه:** شما دیگر هیچ محدودیتی در استفاده از کتابخانه‌های اکوسیستم **React Native** ندارید و در عین حال از سادگی و سرعت توسعه **Expo** (مانند **Fast Refresh** و **Metro Bundler**) بهره‌مند می‌شوید.
• **فرآیند:**
1.  با نصب `expo-dev-client` شروع کنید.
2.  سپس، با اجرای دستور `eas build --profile development`، یک نسخه توسعه از اپلیکیشن خود می‌سازید.
3.  شما می‌توانید این بیلد را روی دستگاه‌های واقعی نصب کنید و از آن به جای **Expo Go** برای توسعه روزمره خود استفاده کنید.

***

## فصل ۱۵: از کد تا کاربر: ساخت و انتشار با EAS

در این فصل پایانی، فرآیند تبدیل کد به یک اپلیکیشن واقعی و قابل انتشار را از طریق سرویس‌های **EAS (Expo Application Services)** طی می‌کنیم.

### ۱۵-۱: EAS Build

• این سرویس ابری **Expo**، کدهای شما را دریافت کرده و فایل‌های نهایی اپلیکیشن را در فضای ابری برایتان می‌سازد.
• **خروجی:** فایل `.apk` یا `.aab` برای اندروید و `.ipa` برای iOS.
• **مزیت:**
    • بدون نیاز به داشتن مک برای ساخت خروجی iOS.
    • بدون درگیر شدن با تنظیمات پیچیده **Xcode** و **Android Studio**.
    • تمام فرآیند ساخت در محیط ابری **Expo** انجام می‌شود.
• **دستور:** `eas build --platform all` (برای ساخت بیلد برای هر دو پلتفرم)

### ۱۵-۲: EAS Update (آپدیت هوایی - OTA)

• این قابلیت قدرتمند به شما اجازه می‌دهد تمام تغییرات جاوااسکریپت (مانند اصلاح باگ، تغییرات ظاهری، بهبودهای **UI**) را **بدون نیاز به انتشار نسخه جدید در اپ استور**، مستقیماً برای کاربران خود ارسال کنید.
• این به شما امکان می‌دهد باگ‌ها را به سرعت برطرف کنید یا تغییرات کوچک را بدون نیاز به فرآیند طولانی بررسی اپ استورها، به کاربران ارائه دهید.
• **دستور:** `eas update`

### ۱۵-۳: EAS Submit

• این سرویس، فرآیند آپلود کردن فایل نهایی اپلیکیشن به **Google Play Console** (برای اندروید) و **App Store Connect** (برای iOS) را به صورت خودکار از طریق خط فرمان انجام می‌دهد.
• این کار باعث صرفه‌جویی زیادی در زمان و کاهش خطاهای انسانی در فرآیند انتشار می‌شود.
• **دستور:**
    • `eas submit -p android` (برای اندروید)
    • `eas submit -p ios` (برای iOS)

***

## پایان دوره

تبریک! شما با موفقیت تمام مراحل ساخت یک اپلیکیشن مدرن با **React Native** و **Expo** را از صفر تا صد طی کردید. شما اکنون دانش و ابزارهای لازم برای تبدیل هر ایده‌ای به یک اپلیکیشن واقعی، باکیفیت و قابل انتشار را در اختیار دارید.

قدم بعدی، شروع ساخت پروژه شخصی خودتان است. موفق باشید! 🚀
